// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_CHANGE_MOVE_DIR;
struct C_CHANGE_MOVE_DIRDefaultTypeInternal;
extern C_CHANGE_MOVE_DIRDefaultTypeInternal _C_CHANGE_MOVE_DIR_default_instance_;
class C_CHANGE_STATE;
struct C_CHANGE_STATEDefaultTypeInternal;
extern C_CHANGE_STATEDefaultTypeInternal _C_CHANGE_STATE_default_instance_;
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_CREATE_PLAYER;
struct C_CREATE_PLAYERDefaultTypeInternal;
extern C_CREATE_PLAYERDefaultTypeInternal _C_CREATE_PLAYER_default_instance_;
class C_ENTER_GAME;
struct C_ENTER_GAMEDefaultTypeInternal;
extern C_ENTER_GAMEDefaultTypeInternal _C_ENTER_GAME_default_instance_;
class C_EQUIP_ITEM;
struct C_EQUIP_ITEMDefaultTypeInternal;
extern C_EQUIP_ITEMDefaultTypeInternal _C_EQUIP_ITEM_default_instance_;
class C_LOGIN;
struct C_LOGINDefaultTypeInternal;
extern C_LOGINDefaultTypeInternal _C_LOGIN_default_instance_;
class C_MOVE;
struct C_MOVEDefaultTypeInternal;
extern C_MOVEDefaultTypeInternal _C_MOVE_default_instance_;
class C_PONG;
struct C_PONGDefaultTypeInternal;
extern C_PONGDefaultTypeInternal _C_PONG_default_instance_;
class C_POSITION;
struct C_POSITIONDefaultTypeInternal;
extern C_POSITIONDefaultTypeInternal _C_POSITION_default_instance_;
class C_SKILL;
struct C_SKILLDefaultTypeInternal;
extern C_SKILLDefaultTypeInternal _C_SKILL_default_instance_;
class L_C_CREATE_ACCOUNT;
struct L_C_CREATE_ACCOUNTDefaultTypeInternal;
extern L_C_CREATE_ACCOUNTDefaultTypeInternal _L_C_CREATE_ACCOUNT_default_instance_;
class L_C_LOGIN_ACCOUNT;
struct L_C_LOGIN_ACCOUNTDefaultTypeInternal;
extern L_C_LOGIN_ACCOUNTDefaultTypeInternal _L_C_LOGIN_ACCOUNT_default_instance_;
class L_S_CONNECTED;
struct L_S_CONNECTEDDefaultTypeInternal;
extern L_S_CONNECTEDDefaultTypeInternal _L_S_CONNECTED_default_instance_;
class L_S_CREATE_ACCOUNT;
struct L_S_CREATE_ACCOUNTDefaultTypeInternal;
extern L_S_CREATE_ACCOUNTDefaultTypeInternal _L_S_CREATE_ACCOUNT_default_instance_;
class L_S_LOGIN_ACCOUNT;
struct L_S_LOGIN_ACCOUNTDefaultTypeInternal;
extern L_S_LOGIN_ACCOUNTDefaultTypeInternal _L_S_LOGIN_ACCOUNT_default_instance_;
class S_ADD_ITEM;
struct S_ADD_ITEMDefaultTypeInternal;
extern S_ADD_ITEMDefaultTypeInternal _S_ADD_ITEM_default_instance_;
class S_CHANGE_HP;
struct S_CHANGE_HPDefaultTypeInternal;
extern S_CHANGE_HPDefaultTypeInternal _S_CHANGE_HP_default_instance_;
class S_CHANGE_MOVE_DIR;
struct S_CHANGE_MOVE_DIRDefaultTypeInternal;
extern S_CHANGE_MOVE_DIRDefaultTypeInternal _S_CHANGE_MOVE_DIR_default_instance_;
class S_CHANGE_STAT;
struct S_CHANGE_STATDefaultTypeInternal;
extern S_CHANGE_STATDefaultTypeInternal _S_CHANGE_STAT_default_instance_;
class S_CHANGE_STATE;
struct S_CHANGE_STATEDefaultTypeInternal;
extern S_CHANGE_STATEDefaultTypeInternal _S_CHANGE_STATE_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_CONNECTED;
struct S_CONNECTEDDefaultTypeInternal;
extern S_CONNECTEDDefaultTypeInternal _S_CONNECTED_default_instance_;
class S_CREATE_PLAYER;
struct S_CREATE_PLAYERDefaultTypeInternal;
extern S_CREATE_PLAYERDefaultTypeInternal _S_CREATE_PLAYER_default_instance_;
class S_DEATH;
struct S_DEATHDefaultTypeInternal;
extern S_DEATHDefaultTypeInternal _S_DEATH_default_instance_;
class S_DESPAWN;
struct S_DESPAWNDefaultTypeInternal;
extern S_DESPAWNDefaultTypeInternal _S_DESPAWN_default_instance_;
class S_ENTER_GAME;
struct S_ENTER_GAMEDefaultTypeInternal;
extern S_ENTER_GAMEDefaultTypeInternal _S_ENTER_GAME_default_instance_;
class S_EQUIP_ITEM;
struct S_EQUIP_ITEMDefaultTypeInternal;
extern S_EQUIP_ITEMDefaultTypeInternal _S_EQUIP_ITEM_default_instance_;
class S_ITEM_LIST;
struct S_ITEM_LISTDefaultTypeInternal;
extern S_ITEM_LISTDefaultTypeInternal _S_ITEM_LIST_default_instance_;
class S_LEAVE_GAME;
struct S_LEAVE_GAMEDefaultTypeInternal;
extern S_LEAVE_GAMEDefaultTypeInternal _S_LEAVE_GAME_default_instance_;
class S_LOGIN;
struct S_LOGINDefaultTypeInternal;
extern S_LOGINDefaultTypeInternal _S_LOGIN_default_instance_;
class S_MOVE;
struct S_MOVEDefaultTypeInternal;
extern S_MOVEDefaultTypeInternal _S_MOVE_default_instance_;
class S_PING;
struct S_PINGDefaultTypeInternal;
extern S_PINGDefaultTypeInternal _S_PING_default_instance_;
class S_POSITION;
struct S_POSITIONDefaultTypeInternal;
extern S_POSITIONDefaultTypeInternal _S_POSITION_default_instance_;
class S_SKILL;
struct S_SKILLDefaultTypeInternal;
extern S_SKILLDefaultTypeInternal _S_SKILL_default_instance_;
class S_SPAWN;
struct S_SPAWNDefaultTypeInternal;
extern S_SPAWNDefaultTypeInternal _S_SPAWN_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_CHANGE_MOVE_DIR* Arena::CreateMaybeMessage<::Protocol::C_CHANGE_MOVE_DIR>(Arena*);
template<> ::Protocol::C_CHANGE_STATE* Arena::CreateMaybeMessage<::Protocol::C_CHANGE_STATE>(Arena*);
template<> ::Protocol::C_CHAT* Arena::CreateMaybeMessage<::Protocol::C_CHAT>(Arena*);
template<> ::Protocol::C_CREATE_PLAYER* Arena::CreateMaybeMessage<::Protocol::C_CREATE_PLAYER>(Arena*);
template<> ::Protocol::C_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::C_ENTER_GAME>(Arena*);
template<> ::Protocol::C_EQUIP_ITEM* Arena::CreateMaybeMessage<::Protocol::C_EQUIP_ITEM>(Arena*);
template<> ::Protocol::C_LOGIN* Arena::CreateMaybeMessage<::Protocol::C_LOGIN>(Arena*);
template<> ::Protocol::C_MOVE* Arena::CreateMaybeMessage<::Protocol::C_MOVE>(Arena*);
template<> ::Protocol::C_PONG* Arena::CreateMaybeMessage<::Protocol::C_PONG>(Arena*);
template<> ::Protocol::C_POSITION* Arena::CreateMaybeMessage<::Protocol::C_POSITION>(Arena*);
template<> ::Protocol::C_SKILL* Arena::CreateMaybeMessage<::Protocol::C_SKILL>(Arena*);
template<> ::Protocol::L_C_CREATE_ACCOUNT* Arena::CreateMaybeMessage<::Protocol::L_C_CREATE_ACCOUNT>(Arena*);
template<> ::Protocol::L_C_LOGIN_ACCOUNT* Arena::CreateMaybeMessage<::Protocol::L_C_LOGIN_ACCOUNT>(Arena*);
template<> ::Protocol::L_S_CONNECTED* Arena::CreateMaybeMessage<::Protocol::L_S_CONNECTED>(Arena*);
template<> ::Protocol::L_S_CREATE_ACCOUNT* Arena::CreateMaybeMessage<::Protocol::L_S_CREATE_ACCOUNT>(Arena*);
template<> ::Protocol::L_S_LOGIN_ACCOUNT* Arena::CreateMaybeMessage<::Protocol::L_S_LOGIN_ACCOUNT>(Arena*);
template<> ::Protocol::S_ADD_ITEM* Arena::CreateMaybeMessage<::Protocol::S_ADD_ITEM>(Arena*);
template<> ::Protocol::S_CHANGE_HP* Arena::CreateMaybeMessage<::Protocol::S_CHANGE_HP>(Arena*);
template<> ::Protocol::S_CHANGE_MOVE_DIR* Arena::CreateMaybeMessage<::Protocol::S_CHANGE_MOVE_DIR>(Arena*);
template<> ::Protocol::S_CHANGE_STAT* Arena::CreateMaybeMessage<::Protocol::S_CHANGE_STAT>(Arena*);
template<> ::Protocol::S_CHANGE_STATE* Arena::CreateMaybeMessage<::Protocol::S_CHANGE_STATE>(Arena*);
template<> ::Protocol::S_CHAT* Arena::CreateMaybeMessage<::Protocol::S_CHAT>(Arena*);
template<> ::Protocol::S_CONNECTED* Arena::CreateMaybeMessage<::Protocol::S_CONNECTED>(Arena*);
template<> ::Protocol::S_CREATE_PLAYER* Arena::CreateMaybeMessage<::Protocol::S_CREATE_PLAYER>(Arena*);
template<> ::Protocol::S_DEATH* Arena::CreateMaybeMessage<::Protocol::S_DEATH>(Arena*);
template<> ::Protocol::S_DESPAWN* Arena::CreateMaybeMessage<::Protocol::S_DESPAWN>(Arena*);
template<> ::Protocol::S_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::S_ENTER_GAME>(Arena*);
template<> ::Protocol::S_EQUIP_ITEM* Arena::CreateMaybeMessage<::Protocol::S_EQUIP_ITEM>(Arena*);
template<> ::Protocol::S_ITEM_LIST* Arena::CreateMaybeMessage<::Protocol::S_ITEM_LIST>(Arena*);
template<> ::Protocol::S_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::S_LEAVE_GAME>(Arena*);
template<> ::Protocol::S_LOGIN* Arena::CreateMaybeMessage<::Protocol::S_LOGIN>(Arena*);
template<> ::Protocol::S_MOVE* Arena::CreateMaybeMessage<::Protocol::S_MOVE>(Arena*);
template<> ::Protocol::S_PING* Arena::CreateMaybeMessage<::Protocol::S_PING>(Arena*);
template<> ::Protocol::S_POSITION* Arena::CreateMaybeMessage<::Protocol::S_POSITION>(Arena*);
template<> ::Protocol::S_SKILL* Arena::CreateMaybeMessage<::Protocol::S_SKILL>(Arena*);
template<> ::Protocol::S_SPAWN* Arena::CreateMaybeMessage<::Protocol::S_SPAWN>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class L_S_CONNECTED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.L_S_CONNECTED) */ {
 public:
  inline L_S_CONNECTED() : L_S_CONNECTED(nullptr) {}
  ~L_S_CONNECTED() override;
  explicit PROTOBUF_CONSTEXPR L_S_CONNECTED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L_S_CONNECTED(const L_S_CONNECTED& from);
  L_S_CONNECTED(L_S_CONNECTED&& from) noexcept
    : L_S_CONNECTED() {
    *this = ::std::move(from);
  }

  inline L_S_CONNECTED& operator=(const L_S_CONNECTED& from) {
    CopyFrom(from);
    return *this;
  }
  inline L_S_CONNECTED& operator=(L_S_CONNECTED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L_S_CONNECTED& default_instance() {
    return *internal_default_instance();
  }
  static inline const L_S_CONNECTED* internal_default_instance() {
    return reinterpret_cast<const L_S_CONNECTED*>(
               &_L_S_CONNECTED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(L_S_CONNECTED& a, L_S_CONNECTED& b) {
    a.Swap(&b);
  }
  inline void Swap(L_S_CONNECTED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L_S_CONNECTED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L_S_CONNECTED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L_S_CONNECTED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L_S_CONNECTED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const L_S_CONNECTED& from) {
    L_S_CONNECTED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L_S_CONNECTED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.L_S_CONNECTED";
  }
  protected:
  explicit L_S_CONNECTED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.L_S_CONNECTED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class L_C_CREATE_ACCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.L_C_CREATE_ACCOUNT) */ {
 public:
  inline L_C_CREATE_ACCOUNT() : L_C_CREATE_ACCOUNT(nullptr) {}
  ~L_C_CREATE_ACCOUNT() override;
  explicit PROTOBUF_CONSTEXPR L_C_CREATE_ACCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L_C_CREATE_ACCOUNT(const L_C_CREATE_ACCOUNT& from);
  L_C_CREATE_ACCOUNT(L_C_CREATE_ACCOUNT&& from) noexcept
    : L_C_CREATE_ACCOUNT() {
    *this = ::std::move(from);
  }

  inline L_C_CREATE_ACCOUNT& operator=(const L_C_CREATE_ACCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline L_C_CREATE_ACCOUNT& operator=(L_C_CREATE_ACCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L_C_CREATE_ACCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const L_C_CREATE_ACCOUNT* internal_default_instance() {
    return reinterpret_cast<const L_C_CREATE_ACCOUNT*>(
               &_L_C_CREATE_ACCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(L_C_CREATE_ACCOUNT& a, L_C_CREATE_ACCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(L_C_CREATE_ACCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L_C_CREATE_ACCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L_C_CREATE_ACCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L_C_CREATE_ACCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L_C_CREATE_ACCOUNT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const L_C_CREATE_ACCOUNT& from) {
    L_C_CREATE_ACCOUNT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L_C_CREATE_ACCOUNT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.L_C_CREATE_ACCOUNT";
  }
  protected:
  explicit L_C_CREATE_ACCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.L_C_CREATE_ACCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class L_S_CREATE_ACCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.L_S_CREATE_ACCOUNT) */ {
 public:
  inline L_S_CREATE_ACCOUNT() : L_S_CREATE_ACCOUNT(nullptr) {}
  ~L_S_CREATE_ACCOUNT() override;
  explicit PROTOBUF_CONSTEXPR L_S_CREATE_ACCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L_S_CREATE_ACCOUNT(const L_S_CREATE_ACCOUNT& from);
  L_S_CREATE_ACCOUNT(L_S_CREATE_ACCOUNT&& from) noexcept
    : L_S_CREATE_ACCOUNT() {
    *this = ::std::move(from);
  }

  inline L_S_CREATE_ACCOUNT& operator=(const L_S_CREATE_ACCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline L_S_CREATE_ACCOUNT& operator=(L_S_CREATE_ACCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L_S_CREATE_ACCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const L_S_CREATE_ACCOUNT* internal_default_instance() {
    return reinterpret_cast<const L_S_CREATE_ACCOUNT*>(
               &_L_S_CREATE_ACCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(L_S_CREATE_ACCOUNT& a, L_S_CREATE_ACCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(L_S_CREATE_ACCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L_S_CREATE_ACCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L_S_CREATE_ACCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L_S_CREATE_ACCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L_S_CREATE_ACCOUNT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const L_S_CREATE_ACCOUNT& from) {
    L_S_CREATE_ACCOUNT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L_S_CREATE_ACCOUNT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.L_S_CREATE_ACCOUNT";
  }
  protected:
  explicit L_S_CREATE_ACCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateOkFieldNumber = 1,
  };
  // bool createOk = 1;
  void clear_createok();
  bool createok() const;
  void set_createok(bool value);
  private:
  bool _internal_createok() const;
  void _internal_set_createok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.L_S_CREATE_ACCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool createok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class L_C_LOGIN_ACCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.L_C_LOGIN_ACCOUNT) */ {
 public:
  inline L_C_LOGIN_ACCOUNT() : L_C_LOGIN_ACCOUNT(nullptr) {}
  ~L_C_LOGIN_ACCOUNT() override;
  explicit PROTOBUF_CONSTEXPR L_C_LOGIN_ACCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L_C_LOGIN_ACCOUNT(const L_C_LOGIN_ACCOUNT& from);
  L_C_LOGIN_ACCOUNT(L_C_LOGIN_ACCOUNT&& from) noexcept
    : L_C_LOGIN_ACCOUNT() {
    *this = ::std::move(from);
  }

  inline L_C_LOGIN_ACCOUNT& operator=(const L_C_LOGIN_ACCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline L_C_LOGIN_ACCOUNT& operator=(L_C_LOGIN_ACCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L_C_LOGIN_ACCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const L_C_LOGIN_ACCOUNT* internal_default_instance() {
    return reinterpret_cast<const L_C_LOGIN_ACCOUNT*>(
               &_L_C_LOGIN_ACCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(L_C_LOGIN_ACCOUNT& a, L_C_LOGIN_ACCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(L_C_LOGIN_ACCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L_C_LOGIN_ACCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L_C_LOGIN_ACCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L_C_LOGIN_ACCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L_C_LOGIN_ACCOUNT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const L_C_LOGIN_ACCOUNT& from) {
    L_C_LOGIN_ACCOUNT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L_C_LOGIN_ACCOUNT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.L_C_LOGIN_ACCOUNT";
  }
  protected:
  explicit L_C_LOGIN_ACCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.L_C_LOGIN_ACCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class L_S_LOGIN_ACCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.L_S_LOGIN_ACCOUNT) */ {
 public:
  inline L_S_LOGIN_ACCOUNT() : L_S_LOGIN_ACCOUNT(nullptr) {}
  ~L_S_LOGIN_ACCOUNT() override;
  explicit PROTOBUF_CONSTEXPR L_S_LOGIN_ACCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L_S_LOGIN_ACCOUNT(const L_S_LOGIN_ACCOUNT& from);
  L_S_LOGIN_ACCOUNT(L_S_LOGIN_ACCOUNT&& from) noexcept
    : L_S_LOGIN_ACCOUNT() {
    *this = ::std::move(from);
  }

  inline L_S_LOGIN_ACCOUNT& operator=(const L_S_LOGIN_ACCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline L_S_LOGIN_ACCOUNT& operator=(L_S_LOGIN_ACCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L_S_LOGIN_ACCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const L_S_LOGIN_ACCOUNT* internal_default_instance() {
    return reinterpret_cast<const L_S_LOGIN_ACCOUNT*>(
               &_L_S_LOGIN_ACCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(L_S_LOGIN_ACCOUNT& a, L_S_LOGIN_ACCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(L_S_LOGIN_ACCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L_S_LOGIN_ACCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L_S_LOGIN_ACCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L_S_LOGIN_ACCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L_S_LOGIN_ACCOUNT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const L_S_LOGIN_ACCOUNT& from) {
    L_S_LOGIN_ACCOUNT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L_S_LOGIN_ACCOUNT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.L_S_LOGIN_ACCOUNT";
  }
  protected:
  explicit L_S_LOGIN_ACCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerInfosFieldNumber = 5,
    kLoginFailedReasonFieldNumber = 2,
    kLoginOkFieldNumber = 1,
    kAccountIdFieldNumber = 3,
    kTokenFieldNumber = 4,
  };
  // repeated .Protocol.ServerInfo serverInfos = 5;
  int serverinfos_size() const;
  private:
  int _internal_serverinfos_size() const;
  public:
  void clear_serverinfos();
  ::Protocol::ServerInfo* mutable_serverinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ServerInfo >*
      mutable_serverinfos();
  private:
  const ::Protocol::ServerInfo& _internal_serverinfos(int index) const;
  ::Protocol::ServerInfo* _internal_add_serverinfos();
  public:
  const ::Protocol::ServerInfo& serverinfos(int index) const;
  ::Protocol::ServerInfo* add_serverinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ServerInfo >&
      serverinfos() const;

  // string loginFailedReason = 2;
  void clear_loginfailedreason();
  const std::string& loginfailedreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginfailedreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginfailedreason();
  PROTOBUF_NODISCARD std::string* release_loginfailedreason();
  void set_allocated_loginfailedreason(std::string* loginfailedreason);
  private:
  const std::string& _internal_loginfailedreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginfailedreason(const std::string& value);
  std::string* _internal_mutable_loginfailedreason();
  public:

  // bool loginOk = 1;
  void clear_loginok();
  bool loginok() const;
  void set_loginok(bool value);
  private:
  bool _internal_loginok() const;
  void _internal_set_loginok(bool value);
  public:

  // int32 accountId = 3;
  void clear_accountid();
  int32_t accountid() const;
  void set_accountid(int32_t value);
  private:
  int32_t _internal_accountid() const;
  void _internal_set_accountid(int32_t value);
  public:

  // int32 token = 4;
  void clear_token();
  int32_t token() const;
  void set_token(int32_t value);
  private:
  int32_t _internal_token() const;
  void _internal_set_token(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.L_S_LOGIN_ACCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ServerInfo > serverinfos_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginfailedreason_;
    bool loginok_;
    int32_t accountid_;
    int32_t token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CONNECTED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CONNECTED) */ {
 public:
  inline S_CONNECTED() : S_CONNECTED(nullptr) {}
  ~S_CONNECTED() override;
  explicit PROTOBUF_CONSTEXPR S_CONNECTED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CONNECTED(const S_CONNECTED& from);
  S_CONNECTED(S_CONNECTED&& from) noexcept
    : S_CONNECTED() {
    *this = ::std::move(from);
  }

  inline S_CONNECTED& operator=(const S_CONNECTED& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CONNECTED& operator=(S_CONNECTED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CONNECTED& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CONNECTED* internal_default_instance() {
    return reinterpret_cast<const S_CONNECTED*>(
               &_S_CONNECTED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_CONNECTED& a, S_CONNECTED& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CONNECTED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CONNECTED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CONNECTED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CONNECTED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CONNECTED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CONNECTED& from) {
    S_CONNECTED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CONNECTED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CONNECTED";
  }
  protected:
  explicit S_CONNECTED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CONNECTED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LOGIN) */ {
 public:
  inline C_LOGIN() : C_LOGIN(nullptr) {}
  ~C_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR C_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGIN(const C_LOGIN& from);
  C_LOGIN(C_LOGIN&& from) noexcept
    : C_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_LOGIN& operator=(const C_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGIN& operator=(C_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_LOGIN*>(
               &_C_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_LOGIN& a, C_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LOGIN& from) {
    C_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOGIN";
  }
  protected:
  explicit C_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIdFieldNumber = 1,
    kTokenFieldNumber = 2,
    kAccountIdFieldNumber = 3,
  };
  // string uniqueId = 1;
  void clear_uniqueid();
  const std::string& uniqueid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uniqueid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uniqueid();
  PROTOBUF_NODISCARD std::string* release_uniqueid();
  void set_allocated_uniqueid(std::string* uniqueid);
  private:
  const std::string& _internal_uniqueid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uniqueid(const std::string& value);
  std::string* _internal_mutable_uniqueid();
  public:

  // int32 token = 2;
  void clear_token();
  int32_t token() const;
  void set_token(int32_t value);
  private:
  int32_t _internal_token() const;
  void _internal_set_token(int32_t value);
  public:

  // int32 accountId = 3;
  void clear_accountid();
  int32_t accountid() const;
  void set_accountid(int32_t value);
  private:
  int32_t _internal_accountid() const;
  void _internal_set_accountid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uniqueid_;
    int32_t token_;
    int32_t accountid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOGIN) */ {
 public:
  inline S_LOGIN() : S_LOGIN(nullptr) {}
  ~S_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR S_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGIN(const S_LOGIN& from);
  S_LOGIN(S_LOGIN&& from) noexcept
    : S_LOGIN() {
    *this = ::std::move(from);
  }

  inline S_LOGIN& operator=(const S_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGIN& operator=(S_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGIN* internal_default_instance() {
    return reinterpret_cast<const S_LOGIN*>(
               &_S_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_LOGIN& a, S_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOGIN& from) {
    S_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOGIN";
  }
  protected:
  explicit S_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLobbyPlayersFieldNumber = 2,
    kLoginOkFieldNumber = 1,
  };
  // repeated .Protocol.LobbyPlayerInfo lobbyPlayers = 2;
  int lobbyplayers_size() const;
  private:
  int _internal_lobbyplayers_size() const;
  public:
  void clear_lobbyplayers();
  ::Protocol::LobbyPlayerInfo* mutable_lobbyplayers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >*
      mutable_lobbyplayers();
  private:
  const ::Protocol::LobbyPlayerInfo& _internal_lobbyplayers(int index) const;
  ::Protocol::LobbyPlayerInfo* _internal_add_lobbyplayers();
  public:
  const ::Protocol::LobbyPlayerInfo& lobbyplayers(int index) const;
  ::Protocol::LobbyPlayerInfo* add_lobbyplayers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >&
      lobbyplayers() const;

  // int32 loginOk = 1;
  void clear_loginok();
  int32_t loginok() const;
  void set_loginok(int32_t value);
  private:
  int32_t _internal_loginok() const;
  void _internal_set_loginok(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo > lobbyplayers_;
    int32_t loginok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CREATE_PLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CREATE_PLAYER) */ {
 public:
  inline C_CREATE_PLAYER() : C_CREATE_PLAYER(nullptr) {}
  ~C_CREATE_PLAYER() override;
  explicit PROTOBUF_CONSTEXPR C_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CREATE_PLAYER(const C_CREATE_PLAYER& from);
  C_CREATE_PLAYER(C_CREATE_PLAYER&& from) noexcept
    : C_CREATE_PLAYER() {
    *this = ::std::move(from);
  }

  inline C_CREATE_PLAYER& operator=(const C_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CREATE_PLAYER& operator=(C_CREATE_PLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CREATE_PLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CREATE_PLAYER* internal_default_instance() {
    return reinterpret_cast<const C_CREATE_PLAYER*>(
               &_C_CREATE_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(C_CREATE_PLAYER& a, C_CREATE_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CREATE_PLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CREATE_PLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CREATE_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CREATE_PLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CREATE_PLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CREATE_PLAYER& from) {
    C_CREATE_PLAYER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CREATE_PLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CREATE_PLAYER";
  }
  protected:
  explicit C_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CREATE_PLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CREATE_PLAYER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CREATE_PLAYER) */ {
 public:
  inline S_CREATE_PLAYER() : S_CREATE_PLAYER(nullptr) {}
  ~S_CREATE_PLAYER() override;
  explicit PROTOBUF_CONSTEXPR S_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CREATE_PLAYER(const S_CREATE_PLAYER& from);
  S_CREATE_PLAYER(S_CREATE_PLAYER&& from) noexcept
    : S_CREATE_PLAYER() {
    *this = ::std::move(from);
  }

  inline S_CREATE_PLAYER& operator=(const S_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CREATE_PLAYER& operator=(S_CREATE_PLAYER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CREATE_PLAYER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CREATE_PLAYER* internal_default_instance() {
    return reinterpret_cast<const S_CREATE_PLAYER*>(
               &_S_CREATE_PLAYER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_CREATE_PLAYER& a, S_CREATE_PLAYER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CREATE_PLAYER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CREATE_PLAYER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CREATE_PLAYER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CREATE_PLAYER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CREATE_PLAYER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CREATE_PLAYER& from) {
    S_CREATE_PLAYER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CREATE_PLAYER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CREATE_PLAYER";
  }
  protected:
  explicit S_CREATE_PLAYER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatePlayerFieldNumber = 2,
    kCreateOkFieldNumber = 1,
  };
  // .Protocol.LobbyPlayerInfo createPlayer = 2;
  bool has_createplayer() const;
  private:
  bool _internal_has_createplayer() const;
  public:
  void clear_createplayer();
  const ::Protocol::LobbyPlayerInfo& createplayer() const;
  PROTOBUF_NODISCARD ::Protocol::LobbyPlayerInfo* release_createplayer();
  ::Protocol::LobbyPlayerInfo* mutable_createplayer();
  void set_allocated_createplayer(::Protocol::LobbyPlayerInfo* createplayer);
  private:
  const ::Protocol::LobbyPlayerInfo& _internal_createplayer() const;
  ::Protocol::LobbyPlayerInfo* _internal_mutable_createplayer();
  public:
  void unsafe_arena_set_allocated_createplayer(
      ::Protocol::LobbyPlayerInfo* createplayer);
  ::Protocol::LobbyPlayerInfo* unsafe_arena_release_createplayer();

  // int32 createOk = 1;
  void clear_createok();
  int32_t createok() const;
  void set_createok(int32_t value);
  private:
  int32_t _internal_createok() const;
  void _internal_set_createok(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CREATE_PLAYER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::LobbyPlayerInfo* createplayer_;
    int32_t createok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_GAME) */ {
 public:
  inline C_ENTER_GAME() : C_ENTER_GAME(nullptr) {}
  ~C_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_GAME(const C_ENTER_GAME& from);
  C_ENTER_GAME(C_ENTER_GAME&& from) noexcept
    : C_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline C_ENTER_GAME& operator=(const C_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_GAME& operator=(C_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_GAME*>(
               &_C_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_ENTER_GAME& a, C_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER_GAME& from) {
    C_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_GAME";
  }
  protected:
  explicit C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER_GAME) */ {
 public:
  inline S_ENTER_GAME() : S_ENTER_GAME(nullptr) {}
  ~S_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_GAME(const S_ENTER_GAME& from);
  S_ENTER_GAME(S_ENTER_GAME&& from) noexcept
    : S_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline S_ENTER_GAME& operator=(const S_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_GAME& operator=(S_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_GAME*>(
               &_S_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_ENTER_GAME& a, S_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTER_GAME& from) {
    S_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER_GAME";
  }
  protected:
  explicit S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.ActorInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ActorInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::ActorInfo* release_player();
  ::Protocol::ActorInfo* mutable_player();
  void set_allocated_player(::Protocol::ActorInfo* player);
  private:
  const ::Protocol::ActorInfo& _internal_player() const;
  ::Protocol::ActorInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ActorInfo* player);
  ::Protocol::ActorInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ActorInfo* player_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_LEAVE_GAME) */ {
 public:
  inline S_LEAVE_GAME() : S_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEAVE_GAME(const S_LEAVE_GAME& from);
  S_LEAVE_GAME(S_LEAVE_GAME&& from) noexcept
    : S_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline S_LEAVE_GAME& operator=(const S_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEAVE_GAME& operator=(S_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const S_LEAVE_GAME*>(
               &_S_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_LEAVE_GAME& a, S_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEAVE_GAME";
  }
  protected:
  explicit S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ITEM_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ITEM_LIST) */ {
 public:
  inline S_ITEM_LIST() : S_ITEM_LIST(nullptr) {}
  ~S_ITEM_LIST() override;
  explicit PROTOBUF_CONSTEXPR S_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ITEM_LIST(const S_ITEM_LIST& from);
  S_ITEM_LIST(S_ITEM_LIST&& from) noexcept
    : S_ITEM_LIST() {
    *this = ::std::move(from);
  }

  inline S_ITEM_LIST& operator=(const S_ITEM_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ITEM_LIST& operator=(S_ITEM_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ITEM_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ITEM_LIST* internal_default_instance() {
    return reinterpret_cast<const S_ITEM_LIST*>(
               &_S_ITEM_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_ITEM_LIST& a, S_ITEM_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ITEM_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ITEM_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ITEM_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ITEM_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ITEM_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ITEM_LIST& from) {
    S_ITEM_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ITEM_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ITEM_LIST";
  }
  protected:
  explicit S_ITEM_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemInfosFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo itemInfos = 1;
  int iteminfos_size() const;
  private:
  int _internal_iteminfos_size() const;
  public:
  void clear_iteminfos();
  ::Protocol::ItemInfo* mutable_iteminfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_iteminfos();
  private:
  const ::Protocol::ItemInfo& _internal_iteminfos(int index) const;
  ::Protocol::ItemInfo* _internal_add_iteminfos();
  public:
  const ::Protocol::ItemInfo& iteminfos(int index) const;
  ::Protocol::ItemInfo* add_iteminfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      iteminfos() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_ITEM_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > iteminfos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ADD_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ADD_ITEM) */ {
 public:
  inline S_ADD_ITEM() : S_ADD_ITEM(nullptr) {}
  ~S_ADD_ITEM() override;
  explicit PROTOBUF_CONSTEXPR S_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ADD_ITEM(const S_ADD_ITEM& from);
  S_ADD_ITEM(S_ADD_ITEM&& from) noexcept
    : S_ADD_ITEM() {
    *this = ::std::move(from);
  }

  inline S_ADD_ITEM& operator=(const S_ADD_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ADD_ITEM& operator=(S_ADD_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ADD_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ADD_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_ADD_ITEM*>(
               &_S_ADD_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_ADD_ITEM& a, S_ADD_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ADD_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ADD_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ADD_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ADD_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ADD_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ADD_ITEM& from) {
    S_ADD_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ADD_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ADD_ITEM";
  }
  protected:
  explicit S_ADD_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemInfosFieldNumber = 1,
  };
  // repeated .Protocol.ItemInfo itemInfos = 1;
  int iteminfos_size() const;
  private:
  int _internal_iteminfos_size() const;
  public:
  void clear_iteminfos();
  ::Protocol::ItemInfo* mutable_iteminfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
      mutable_iteminfos();
  private:
  const ::Protocol::ItemInfo& _internal_iteminfos(int index) const;
  ::Protocol::ItemInfo* _internal_add_iteminfos();
  public:
  const ::Protocol::ItemInfo& iteminfos(int index) const;
  ::Protocol::ItemInfo* add_iteminfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
      iteminfos() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_ADD_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo > iteminfos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EQUIP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EQUIP_ITEM) */ {
 public:
  inline C_EQUIP_ITEM() : C_EQUIP_ITEM(nullptr) {}
  ~C_EQUIP_ITEM() override;
  explicit PROTOBUF_CONSTEXPR C_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EQUIP_ITEM(const C_EQUIP_ITEM& from);
  C_EQUIP_ITEM(C_EQUIP_ITEM&& from) noexcept
    : C_EQUIP_ITEM() {
    *this = ::std::move(from);
  }

  inline C_EQUIP_ITEM& operator=(const C_EQUIP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EQUIP_ITEM& operator=(C_EQUIP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EQUIP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EQUIP_ITEM* internal_default_instance() {
    return reinterpret_cast<const C_EQUIP_ITEM*>(
               &_C_EQUIP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(C_EQUIP_ITEM& a, C_EQUIP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EQUIP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EQUIP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EQUIP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EQUIP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EQUIP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EQUIP_ITEM& from) {
    C_EQUIP_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EQUIP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EQUIP_ITEM";
  }
  protected:
  explicit C_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
    kEquippedFieldNumber = 2,
  };
  // int32 itemDbId = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // bool equipped = 2;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EQUIP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t itemdbid_;
    bool equipped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EQUIP_ITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EQUIP_ITEM) */ {
 public:
  inline S_EQUIP_ITEM() : S_EQUIP_ITEM(nullptr) {}
  ~S_EQUIP_ITEM() override;
  explicit PROTOBUF_CONSTEXPR S_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EQUIP_ITEM(const S_EQUIP_ITEM& from);
  S_EQUIP_ITEM(S_EQUIP_ITEM&& from) noexcept
    : S_EQUIP_ITEM() {
    *this = ::std::move(from);
  }

  inline S_EQUIP_ITEM& operator=(const S_EQUIP_ITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EQUIP_ITEM& operator=(S_EQUIP_ITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EQUIP_ITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EQUIP_ITEM* internal_default_instance() {
    return reinterpret_cast<const S_EQUIP_ITEM*>(
               &_S_EQUIP_ITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_EQUIP_ITEM& a, S_EQUIP_ITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EQUIP_ITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EQUIP_ITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EQUIP_ITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EQUIP_ITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EQUIP_ITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EQUIP_ITEM& from) {
    S_EQUIP_ITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EQUIP_ITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EQUIP_ITEM";
  }
  protected:
  explicit S_EQUIP_ITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemDbIdFieldNumber = 1,
    kEquippedFieldNumber = 2,
  };
  // int32 itemDbId = 1;
  void clear_itemdbid();
  int32_t itemdbid() const;
  void set_itemdbid(int32_t value);
  private:
  int32_t _internal_itemdbid() const;
  void _internal_set_itemdbid(int32_t value);
  public:

  // bool equipped = 2;
  void clear_equipped();
  bool equipped() const;
  void set_equipped(bool value);
  private:
  bool _internal_equipped() const;
  void _internal_set_equipped(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EQUIP_ITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t itemdbid_;
    bool equipped_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWN) */ {
 public:
  inline S_SPAWN() : S_SPAWN(nullptr) {}
  ~S_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWN(const S_SPAWN& from);
  S_SPAWN(S_SPAWN&& from) noexcept
    : S_SPAWN() {
    *this = ::std::move(from);
  }

  inline S_SPAWN& operator=(const S_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWN& operator=(S_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWN* internal_default_instance() {
    return reinterpret_cast<const S_SPAWN*>(
               &_S_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_SPAWN& a, S_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWN& from) {
    S_SPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWN";
  }
  protected:
  explicit S_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorsFieldNumber = 1,
  };
  // repeated .Protocol.ActorInfo actors = 1;
  int actors_size() const;
  private:
  int _internal_actors_size() const;
  public:
  void clear_actors();
  ::Protocol::ActorInfo* mutable_actors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo >*
      mutable_actors();
  private:
  const ::Protocol::ActorInfo& _internal_actors(int index) const;
  ::Protocol::ActorInfo* _internal_add_actors();
  public:
  const ::Protocol::ActorInfo& actors(int index) const;
  ::Protocol::ActorInfo* add_actors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo >&
      actors() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo > actors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DESPAWN) */ {
 public:
  inline S_DESPAWN() : S_DESPAWN(nullptr) {}
  ~S_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DESPAWN(const S_DESPAWN& from);
  S_DESPAWN(S_DESPAWN&& from) noexcept
    : S_DESPAWN() {
    *this = ::std::move(from);
  }

  inline S_DESPAWN& operator=(const S_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DESPAWN& operator=(S_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const S_DESPAWN*>(
               &_S_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_DESPAWN& a, S_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DESPAWN& from) {
    S_DESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DESPAWN";
  }
  protected:
  explicit S_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 1,
  };
  // repeated int32 actorId = 1;
  int actorid_size() const;
  private:
  int _internal_actorid_size() const;
  public:
  void clear_actorid();
  private:
  int32_t _internal_actorid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_actorid() const;
  void _internal_add_actorid(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_actorid();
  public:
  int32_t actorid(int index) const;
  void set_actorid(int index, int32_t value);
  void add_actorid(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      actorid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_actorid();

  // @@protoc_insertion_point(class_scope:Protocol.S_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > actorid_;
    mutable std::atomic<int> _actorid_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MOVE) */ {
 public:
  inline C_MOVE() : C_MOVE(nullptr) {}
  ~C_MOVE() override;
  explicit PROTOBUF_CONSTEXPR C_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVE(const C_MOVE& from);
  C_MOVE(C_MOVE&& from) noexcept
    : C_MOVE() {
    *this = ::std::move(from);
  }

  inline C_MOVE& operator=(const C_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVE& operator=(C_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_MOVE*>(
               &_C_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(C_MOVE& a, C_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MOVE& from) {
    C_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MOVE";
  }
  protected:
  explicit C_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionInfoFieldNumber = 1,
  };
  // .Protocol.PositionInfo positionInfo = 1;
  bool has_positioninfo() const;
  private:
  bool _internal_has_positioninfo() const;
  public:
  void clear_positioninfo();
  const ::Protocol::PositionInfo& positioninfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_positioninfo();
  ::Protocol::PositionInfo* mutable_positioninfo();
  void set_allocated_positioninfo(::Protocol::PositionInfo* positioninfo);
  private:
  const ::Protocol::PositionInfo& _internal_positioninfo() const;
  ::Protocol::PositionInfo* _internal_mutable_positioninfo();
  public:
  void unsafe_arena_set_allocated_positioninfo(
      ::Protocol::PositionInfo* positioninfo);
  ::Protocol::PositionInfo* unsafe_arena_release_positioninfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* positioninfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVE) */ {
 public:
  inline S_MOVE() : S_MOVE(nullptr) {}
  ~S_MOVE() override;
  explicit PROTOBUF_CONSTEXPR S_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVE(const S_MOVE& from);
  S_MOVE(S_MOVE&& from) noexcept
    : S_MOVE() {
    *this = ::std::move(from);
  }

  inline S_MOVE& operator=(const S_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVE& operator=(S_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_MOVE*>(
               &_S_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_MOVE& a, S_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MOVE& from) {
    S_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVE";
  }
  protected:
  explicit S_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionInfoFieldNumber = 2,
    kActorIdFieldNumber = 1,
  };
  // .Protocol.PositionInfo positionInfo = 2;
  bool has_positioninfo() const;
  private:
  bool _internal_has_positioninfo() const;
  public:
  void clear_positioninfo();
  const ::Protocol::PositionInfo& positioninfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_positioninfo();
  ::Protocol::PositionInfo* mutable_positioninfo();
  void set_allocated_positioninfo(::Protocol::PositionInfo* positioninfo);
  private:
  const ::Protocol::PositionInfo& _internal_positioninfo() const;
  ::Protocol::PositionInfo* _internal_mutable_positioninfo();
  public:
  void unsafe_arena_set_allocated_positioninfo(
      ::Protocol::PositionInfo* positioninfo);
  ::Protocol::PositionInfo* unsafe_arena_release_positioninfo();

  // int32 actorId = 1;
  void clear_actorid();
  int32_t actorid() const;
  void set_actorid(int32_t value);
  private:
  int32_t _internal_actorid() const;
  void _internal_set_actorid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* positioninfo_;
    int32_t actorid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SKILL) */ {
 public:
  inline C_SKILL() : C_SKILL(nullptr) {}
  ~C_SKILL() override;
  explicit PROTOBUF_CONSTEXPR C_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SKILL(const C_SKILL& from);
  C_SKILL(C_SKILL&& from) noexcept
    : C_SKILL() {
    *this = ::std::move(from);
  }

  inline C_SKILL& operator=(const C_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SKILL& operator=(C_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SKILL* internal_default_instance() {
    return reinterpret_cast<const C_SKILL*>(
               &_C_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(C_SKILL& a, C_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SKILL& from) {
    C_SKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SKILL";
  }
  protected:
  explicit C_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillInfoFieldNumber = 1,
  };
  // .Protocol.SkillInfo skillInfo = 1;
  bool has_skillinfo() const;
  private:
  bool _internal_has_skillinfo() const;
  public:
  void clear_skillinfo();
  const ::Protocol::SkillInfo& skillinfo() const;
  PROTOBUF_NODISCARD ::Protocol::SkillInfo* release_skillinfo();
  ::Protocol::SkillInfo* mutable_skillinfo();
  void set_allocated_skillinfo(::Protocol::SkillInfo* skillinfo);
  private:
  const ::Protocol::SkillInfo& _internal_skillinfo() const;
  ::Protocol::SkillInfo* _internal_mutable_skillinfo();
  public:
  void unsafe_arena_set_allocated_skillinfo(
      ::Protocol::SkillInfo* skillinfo);
  ::Protocol::SkillInfo* unsafe_arena_release_skillinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::SkillInfo* skillinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SKILL) */ {
 public:
  inline S_SKILL() : S_SKILL(nullptr) {}
  ~S_SKILL() override;
  explicit PROTOBUF_CONSTEXPR S_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SKILL(const S_SKILL& from);
  S_SKILL(S_SKILL&& from) noexcept
    : S_SKILL() {
    *this = ::std::move(from);
  }

  inline S_SKILL& operator=(const S_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SKILL& operator=(S_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SKILL* internal_default_instance() {
    return reinterpret_cast<const S_SKILL*>(
               &_S_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_SKILL& a, S_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SKILL& from) {
    S_SKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SKILL";
  }
  protected:
  explicit S_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillInfoFieldNumber = 2,
    kActorIdFieldNumber = 1,
  };
  // .Protocol.SkillInfo skillInfo = 2;
  bool has_skillinfo() const;
  private:
  bool _internal_has_skillinfo() const;
  public:
  void clear_skillinfo();
  const ::Protocol::SkillInfo& skillinfo() const;
  PROTOBUF_NODISCARD ::Protocol::SkillInfo* release_skillinfo();
  ::Protocol::SkillInfo* mutable_skillinfo();
  void set_allocated_skillinfo(::Protocol::SkillInfo* skillinfo);
  private:
  const ::Protocol::SkillInfo& _internal_skillinfo() const;
  ::Protocol::SkillInfo* _internal_mutable_skillinfo();
  public:
  void unsafe_arena_set_allocated_skillinfo(
      ::Protocol::SkillInfo* skillinfo);
  ::Protocol::SkillInfo* unsafe_arena_release_skillinfo();

  // int32 actorId = 1;
  void clear_actorid();
  int32_t actorid() const;
  void set_actorid(int32_t value);
  private:
  int32_t _internal_actorid() const;
  void _internal_set_actorid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::SkillInfo* skillinfo_;
    int32_t actorid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHANGE_HP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHANGE_HP) */ {
 public:
  inline S_CHANGE_HP() : S_CHANGE_HP(nullptr) {}
  ~S_CHANGE_HP() override;
  explicit PROTOBUF_CONSTEXPR S_CHANGE_HP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHANGE_HP(const S_CHANGE_HP& from);
  S_CHANGE_HP(S_CHANGE_HP&& from) noexcept
    : S_CHANGE_HP() {
    *this = ::std::move(from);
  }

  inline S_CHANGE_HP& operator=(const S_CHANGE_HP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHANGE_HP& operator=(S_CHANGE_HP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHANGE_HP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHANGE_HP* internal_default_instance() {
    return reinterpret_cast<const S_CHANGE_HP*>(
               &_S_CHANGE_HP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_CHANGE_HP& a, S_CHANGE_HP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHANGE_HP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHANGE_HP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHANGE_HP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHANGE_HP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHANGE_HP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHANGE_HP& from) {
    S_CHANGE_HP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHANGE_HP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHANGE_HP";
  }
  protected:
  explicit S_CHANGE_HP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 1,
    kHpFieldNumber = 2,
  };
  // int32 actorId = 1;
  void clear_actorid();
  int32_t actorid() const;
  void set_actorid(int32_t value);
  private:
  int32_t _internal_actorid() const;
  void _internal_set_actorid(int32_t value);
  public:

  // int32 hp = 2;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHANGE_HP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t actorid_;
    int32_t hp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHANGE_STAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHANGE_STAT) */ {
 public:
  inline S_CHANGE_STAT() : S_CHANGE_STAT(nullptr) {}
  ~S_CHANGE_STAT() override;
  explicit PROTOBUF_CONSTEXPR S_CHANGE_STAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHANGE_STAT(const S_CHANGE_STAT& from);
  S_CHANGE_STAT(S_CHANGE_STAT&& from) noexcept
    : S_CHANGE_STAT() {
    *this = ::std::move(from);
  }

  inline S_CHANGE_STAT& operator=(const S_CHANGE_STAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHANGE_STAT& operator=(S_CHANGE_STAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHANGE_STAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHANGE_STAT* internal_default_instance() {
    return reinterpret_cast<const S_CHANGE_STAT*>(
               &_S_CHANGE_STAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(S_CHANGE_STAT& a, S_CHANGE_STAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHANGE_STAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHANGE_STAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHANGE_STAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHANGE_STAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHANGE_STAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHANGE_STAT& from) {
    S_CHANGE_STAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHANGE_STAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHANGE_STAT";
  }
  protected:
  explicit S_CHANGE_STAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatInfoFieldNumber = 1,
  };
  // .Protocol.StatInfo statInfo = 1;
  bool has_statinfo() const;
  private:
  bool _internal_has_statinfo() const;
  public:
  void clear_statinfo();
  const ::Protocol::StatInfo& statinfo() const;
  PROTOBUF_NODISCARD ::Protocol::StatInfo* release_statinfo();
  ::Protocol::StatInfo* mutable_statinfo();
  void set_allocated_statinfo(::Protocol::StatInfo* statinfo);
  private:
  const ::Protocol::StatInfo& _internal_statinfo() const;
  ::Protocol::StatInfo* _internal_mutable_statinfo();
  public:
  void unsafe_arena_set_allocated_statinfo(
      ::Protocol::StatInfo* statinfo);
  ::Protocol::StatInfo* unsafe_arena_release_statinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_CHANGE_STAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::StatInfo* statinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DEATH final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DEATH) */ {
 public:
  inline S_DEATH() : S_DEATH(nullptr) {}
  ~S_DEATH() override;
  explicit PROTOBUF_CONSTEXPR S_DEATH(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DEATH(const S_DEATH& from);
  S_DEATH(S_DEATH&& from) noexcept
    : S_DEATH() {
    *this = ::std::move(from);
  }

  inline S_DEATH& operator=(const S_DEATH& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DEATH& operator=(S_DEATH&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DEATH& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DEATH* internal_default_instance() {
    return reinterpret_cast<const S_DEATH*>(
               &_S_DEATH_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(S_DEATH& a, S_DEATH& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DEATH* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DEATH* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DEATH* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DEATH>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DEATH& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DEATH& from) {
    S_DEATH::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DEATH* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DEATH";
  }
  protected:
  explicit S_DEATH(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 1,
    kAttackerIdFieldNumber = 2,
  };
  // int32 actorId = 1;
  void clear_actorid();
  int32_t actorid() const;
  void set_actorid(int32_t value);
  private:
  int32_t _internal_actorid() const;
  void _internal_set_actorid(int32_t value);
  public:

  // int32 attackerId = 2;
  void clear_attackerid();
  int32_t attackerid() const;
  void set_attackerid(int32_t value);
  private:
  int32_t _internal_attackerid() const;
  void _internal_set_attackerid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DEATH)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t actorid_;
    int32_t attackerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHANGE_STATE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHANGE_STATE) */ {
 public:
  inline C_CHANGE_STATE() : C_CHANGE_STATE(nullptr) {}
  ~C_CHANGE_STATE() override;
  explicit PROTOBUF_CONSTEXPR C_CHANGE_STATE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHANGE_STATE(const C_CHANGE_STATE& from);
  C_CHANGE_STATE(C_CHANGE_STATE&& from) noexcept
    : C_CHANGE_STATE() {
    *this = ::std::move(from);
  }

  inline C_CHANGE_STATE& operator=(const C_CHANGE_STATE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHANGE_STATE& operator=(C_CHANGE_STATE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHANGE_STATE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHANGE_STATE* internal_default_instance() {
    return reinterpret_cast<const C_CHANGE_STATE*>(
               &_C_CHANGE_STATE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(C_CHANGE_STATE& a, C_CHANGE_STATE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHANGE_STATE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHANGE_STATE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHANGE_STATE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHANGE_STATE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHANGE_STATE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHANGE_STATE& from) {
    C_CHANGE_STATE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHANGE_STATE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHANGE_STATE";
  }
  protected:
  explicit C_CHANGE_STATE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .Protocol.AIState state = 1;
  void clear_state();
  ::Protocol::AIState state() const;
  void set_state(::Protocol::AIState value);
  private:
  ::Protocol::AIState _internal_state() const;
  void _internal_set_state(::Protocol::AIState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHANGE_STATE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHANGE_STATE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHANGE_STATE) */ {
 public:
  inline S_CHANGE_STATE() : S_CHANGE_STATE(nullptr) {}
  ~S_CHANGE_STATE() override;
  explicit PROTOBUF_CONSTEXPR S_CHANGE_STATE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHANGE_STATE(const S_CHANGE_STATE& from);
  S_CHANGE_STATE(S_CHANGE_STATE&& from) noexcept
    : S_CHANGE_STATE() {
    *this = ::std::move(from);
  }

  inline S_CHANGE_STATE& operator=(const S_CHANGE_STATE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHANGE_STATE& operator=(S_CHANGE_STATE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHANGE_STATE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHANGE_STATE* internal_default_instance() {
    return reinterpret_cast<const S_CHANGE_STATE*>(
               &_S_CHANGE_STATE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_CHANGE_STATE& a, S_CHANGE_STATE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHANGE_STATE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHANGE_STATE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHANGE_STATE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHANGE_STATE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHANGE_STATE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHANGE_STATE& from) {
    S_CHANGE_STATE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHANGE_STATE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHANGE_STATE";
  }
  protected:
  explicit S_CHANGE_STATE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // int32 actorId = 1;
  void clear_actorid();
  int32_t actorid() const;
  void set_actorid(int32_t value);
  private:
  int32_t _internal_actorid() const;
  void _internal_set_actorid(int32_t value);
  public:

  // .Protocol.AIState state = 2;
  void clear_state();
  ::Protocol::AIState state() const;
  void set_state(::Protocol::AIState value);
  private:
  ::Protocol::AIState _internal_state() const;
  void _internal_set_state(::Protocol::AIState value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHANGE_STATE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t actorid_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHANGE_MOVE_DIR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHANGE_MOVE_DIR) */ {
 public:
  inline C_CHANGE_MOVE_DIR() : C_CHANGE_MOVE_DIR(nullptr) {}
  ~C_CHANGE_MOVE_DIR() override;
  explicit PROTOBUF_CONSTEXPR C_CHANGE_MOVE_DIR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHANGE_MOVE_DIR(const C_CHANGE_MOVE_DIR& from);
  C_CHANGE_MOVE_DIR(C_CHANGE_MOVE_DIR&& from) noexcept
    : C_CHANGE_MOVE_DIR() {
    *this = ::std::move(from);
  }

  inline C_CHANGE_MOVE_DIR& operator=(const C_CHANGE_MOVE_DIR& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHANGE_MOVE_DIR& operator=(C_CHANGE_MOVE_DIR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHANGE_MOVE_DIR& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHANGE_MOVE_DIR* internal_default_instance() {
    return reinterpret_cast<const C_CHANGE_MOVE_DIR*>(
               &_C_CHANGE_MOVE_DIR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(C_CHANGE_MOVE_DIR& a, C_CHANGE_MOVE_DIR& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHANGE_MOVE_DIR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHANGE_MOVE_DIR* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHANGE_MOVE_DIR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHANGE_MOVE_DIR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHANGE_MOVE_DIR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHANGE_MOVE_DIR& from) {
    C_CHANGE_MOVE_DIR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHANGE_MOVE_DIR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHANGE_MOVE_DIR";
  }
  protected:
  explicit C_CHANGE_MOVE_DIR(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveDirFieldNumber = 2,
  };
  // .Protocol.MoveDir moveDir = 2;
  void clear_movedir();
  ::Protocol::MoveDir movedir() const;
  void set_movedir(::Protocol::MoveDir value);
  private:
  ::Protocol::MoveDir _internal_movedir() const;
  void _internal_set_movedir(::Protocol::MoveDir value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHANGE_MOVE_DIR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int movedir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHANGE_MOVE_DIR final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHANGE_MOVE_DIR) */ {
 public:
  inline S_CHANGE_MOVE_DIR() : S_CHANGE_MOVE_DIR(nullptr) {}
  ~S_CHANGE_MOVE_DIR() override;
  explicit PROTOBUF_CONSTEXPR S_CHANGE_MOVE_DIR(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHANGE_MOVE_DIR(const S_CHANGE_MOVE_DIR& from);
  S_CHANGE_MOVE_DIR(S_CHANGE_MOVE_DIR&& from) noexcept
    : S_CHANGE_MOVE_DIR() {
    *this = ::std::move(from);
  }

  inline S_CHANGE_MOVE_DIR& operator=(const S_CHANGE_MOVE_DIR& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHANGE_MOVE_DIR& operator=(S_CHANGE_MOVE_DIR&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHANGE_MOVE_DIR& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHANGE_MOVE_DIR* internal_default_instance() {
    return reinterpret_cast<const S_CHANGE_MOVE_DIR*>(
               &_S_CHANGE_MOVE_DIR_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(S_CHANGE_MOVE_DIR& a, S_CHANGE_MOVE_DIR& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHANGE_MOVE_DIR* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHANGE_MOVE_DIR* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHANGE_MOVE_DIR* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHANGE_MOVE_DIR>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHANGE_MOVE_DIR& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHANGE_MOVE_DIR& from) {
    S_CHANGE_MOVE_DIR::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHANGE_MOVE_DIR* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHANGE_MOVE_DIR";
  }
  protected:
  explicit S_CHANGE_MOVE_DIR(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 1,
    kMoveDirFieldNumber = 2,
  };
  // int32 actorId = 1;
  void clear_actorid();
  int32_t actorid() const;
  void set_actorid(int32_t value);
  private:
  int32_t _internal_actorid() const;
  void _internal_set_actorid(int32_t value);
  public:

  // .Protocol.MoveDir moveDir = 2;
  void clear_movedir();
  ::Protocol::MoveDir movedir() const;
  void set_movedir(::Protocol::MoveDir value);
  private:
  ::Protocol::MoveDir _internal_movedir() const;
  void _internal_set_movedir(::Protocol::MoveDir value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHANGE_MOVE_DIR)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t actorid_;
    int movedir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit PROTOBUF_CONSTEXPR C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHAT& from) {
    C_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatFieldNumber = 1,
  };
  // string chat = 1;
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit PROTOBUF_CONSTEXPR S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHAT& from) {
    S_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatFieldNumber = 2,
    kActorIdFieldNumber = 1,
  };
  // string chat = 2;
  void clear_chat();
  const std::string& chat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* chat);
  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(const std::string& value);
  std::string* _internal_mutable_chat();
  public:

  // int32 actorId = 1;
  void clear_actorid();
  int32_t actorid() const;
  void set_actorid(int32_t value);
  private:
  int32_t _internal_actorid() const;
  void _internal_set_actorid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_;
    int32_t actorid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PING final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_PING) */ {
 public:
  inline S_PING() : S_PING(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_PING(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PING(const S_PING& from);
  S_PING(S_PING&& from) noexcept
    : S_PING() {
    *this = ::std::move(from);
  }

  inline S_PING& operator=(const S_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PING& operator=(S_PING&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PING& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PING* internal_default_instance() {
    return reinterpret_cast<const S_PING*>(
               &_S_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(S_PING& a, S_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PING* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PING>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_PING& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_PING& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PING";
  }
  protected:
  explicit S_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PONG final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_PONG) */ {
 public:
  inline C_PONG() : C_PONG(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_PONG(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PONG(const C_PONG& from);
  C_PONG(C_PONG&& from) noexcept
    : C_PONG() {
    *this = ::std::move(from);
  }

  inline C_PONG& operator=(const C_PONG& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PONG& operator=(C_PONG&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PONG& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PONG* internal_default_instance() {
    return reinterpret_cast<const C_PONG*>(
               &_C_PONG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(C_PONG& a, C_PONG& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PONG* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PONG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PONG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PONG>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_PONG& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_PONG& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PONG";
  }
  protected:
  explicit C_PONG(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_PONG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_POSITION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_POSITION) */ {
 public:
  inline C_POSITION() : C_POSITION(nullptr) {}
  ~C_POSITION() override;
  explicit PROTOBUF_CONSTEXPR C_POSITION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_POSITION(const C_POSITION& from);
  C_POSITION(C_POSITION&& from) noexcept
    : C_POSITION() {
    *this = ::std::move(from);
  }

  inline C_POSITION& operator=(const C_POSITION& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_POSITION& operator=(C_POSITION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_POSITION& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_POSITION* internal_default_instance() {
    return reinterpret_cast<const C_POSITION*>(
               &_C_POSITION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(C_POSITION& a, C_POSITION& b) {
    a.Swap(&b);
  }
  inline void Swap(C_POSITION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_POSITION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_POSITION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_POSITION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_POSITION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_POSITION& from) {
    C_POSITION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_POSITION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_POSITION";
  }
  protected:
  explicit C_POSITION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionInfoFieldNumber = 1,
  };
  // .Protocol.PositionInfo positionInfo = 1;
  bool has_positioninfo() const;
  private:
  bool _internal_has_positioninfo() const;
  public:
  void clear_positioninfo();
  const ::Protocol::PositionInfo& positioninfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_positioninfo();
  ::Protocol::PositionInfo* mutable_positioninfo();
  void set_allocated_positioninfo(::Protocol::PositionInfo* positioninfo);
  private:
  const ::Protocol::PositionInfo& _internal_positioninfo() const;
  ::Protocol::PositionInfo* _internal_mutable_positioninfo();
  public:
  void unsafe_arena_set_allocated_positioninfo(
      ::Protocol::PositionInfo* positioninfo);
  ::Protocol::PositionInfo* unsafe_arena_release_positioninfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_POSITION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* positioninfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_POSITION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_POSITION) */ {
 public:
  inline S_POSITION() : S_POSITION(nullptr) {}
  ~S_POSITION() override;
  explicit PROTOBUF_CONSTEXPR S_POSITION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_POSITION(const S_POSITION& from);
  S_POSITION(S_POSITION&& from) noexcept
    : S_POSITION() {
    *this = ::std::move(from);
  }

  inline S_POSITION& operator=(const S_POSITION& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_POSITION& operator=(S_POSITION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_POSITION& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_POSITION* internal_default_instance() {
    return reinterpret_cast<const S_POSITION*>(
               &_S_POSITION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(S_POSITION& a, S_POSITION& b) {
    a.Swap(&b);
  }
  inline void Swap(S_POSITION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_POSITION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_POSITION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_POSITION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_POSITION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_POSITION& from) {
    S_POSITION::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_POSITION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_POSITION";
  }
  protected:
  explicit S_POSITION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionInfoFieldNumber = 2,
    kPositionChangedFieldNumber = 1,
  };
  // .Protocol.PositionInfo positionInfo = 2;
  bool has_positioninfo() const;
  private:
  bool _internal_has_positioninfo() const;
  public:
  void clear_positioninfo();
  const ::Protocol::PositionInfo& positioninfo() const;
  PROTOBUF_NODISCARD ::Protocol::PositionInfo* release_positioninfo();
  ::Protocol::PositionInfo* mutable_positioninfo();
  void set_allocated_positioninfo(::Protocol::PositionInfo* positioninfo);
  private:
  const ::Protocol::PositionInfo& _internal_positioninfo() const;
  ::Protocol::PositionInfo* _internal_mutable_positioninfo();
  public:
  void unsafe_arena_set_allocated_positioninfo(
      ::Protocol::PositionInfo* positioninfo);
  ::Protocol::PositionInfo* unsafe_arena_release_positioninfo();

  // int32 positionChanged = 1;
  void clear_positionchanged();
  int32_t positionchanged() const;
  void set_positionchanged(int32_t value);
  private:
  int32_t _internal_positionchanged() const;
  void _internal_set_positionchanged(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_POSITION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PositionInfo* positioninfo_;
    int32_t positionchanged_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// L_S_CONNECTED

// string name = 1;
inline void L_S_CONNECTED::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& L_S_CONNECTED::name() const {
  // @@protoc_insertion_point(field_get:Protocol.L_S_CONNECTED.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L_S_CONNECTED::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.L_S_CONNECTED.name)
}
inline std::string* L_S_CONNECTED::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.L_S_CONNECTED.name)
  return _s;
}
inline const std::string& L_S_CONNECTED::_internal_name() const {
  return _impl_.name_.Get();
}
inline void L_S_CONNECTED::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* L_S_CONNECTED::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* L_S_CONNECTED::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.L_S_CONNECTED.name)
  return _impl_.name_.Release();
}
inline void L_S_CONNECTED::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.L_S_CONNECTED.name)
}

// -------------------------------------------------------------------

// L_C_CREATE_ACCOUNT

// string name = 1;
inline void L_C_CREATE_ACCOUNT::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& L_C_CREATE_ACCOUNT::name() const {
  // @@protoc_insertion_point(field_get:Protocol.L_C_CREATE_ACCOUNT.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L_C_CREATE_ACCOUNT::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.L_C_CREATE_ACCOUNT.name)
}
inline std::string* L_C_CREATE_ACCOUNT::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.L_C_CREATE_ACCOUNT.name)
  return _s;
}
inline const std::string& L_C_CREATE_ACCOUNT::_internal_name() const {
  return _impl_.name_.Get();
}
inline void L_C_CREATE_ACCOUNT::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* L_C_CREATE_ACCOUNT::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* L_C_CREATE_ACCOUNT::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.L_C_CREATE_ACCOUNT.name)
  return _impl_.name_.Release();
}
inline void L_C_CREATE_ACCOUNT::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.L_C_CREATE_ACCOUNT.name)
}

// string password = 2;
inline void L_C_CREATE_ACCOUNT::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& L_C_CREATE_ACCOUNT::password() const {
  // @@protoc_insertion_point(field_get:Protocol.L_C_CREATE_ACCOUNT.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L_C_CREATE_ACCOUNT::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.L_C_CREATE_ACCOUNT.password)
}
inline std::string* L_C_CREATE_ACCOUNT::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.L_C_CREATE_ACCOUNT.password)
  return _s;
}
inline const std::string& L_C_CREATE_ACCOUNT::_internal_password() const {
  return _impl_.password_.Get();
}
inline void L_C_CREATE_ACCOUNT::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* L_C_CREATE_ACCOUNT::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* L_C_CREATE_ACCOUNT::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.L_C_CREATE_ACCOUNT.password)
  return _impl_.password_.Release();
}
inline void L_C_CREATE_ACCOUNT::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.L_C_CREATE_ACCOUNT.password)
}

// -------------------------------------------------------------------

// L_S_CREATE_ACCOUNT

// bool createOk = 1;
inline void L_S_CREATE_ACCOUNT::clear_createok() {
  _impl_.createok_ = false;
}
inline bool L_S_CREATE_ACCOUNT::_internal_createok() const {
  return _impl_.createok_;
}
inline bool L_S_CREATE_ACCOUNT::createok() const {
  // @@protoc_insertion_point(field_get:Protocol.L_S_CREATE_ACCOUNT.createOk)
  return _internal_createok();
}
inline void L_S_CREATE_ACCOUNT::_internal_set_createok(bool value) {
  
  _impl_.createok_ = value;
}
inline void L_S_CREATE_ACCOUNT::set_createok(bool value) {
  _internal_set_createok(value);
  // @@protoc_insertion_point(field_set:Protocol.L_S_CREATE_ACCOUNT.createOk)
}

// -------------------------------------------------------------------

// L_C_LOGIN_ACCOUNT

// string name = 1;
inline void L_C_LOGIN_ACCOUNT::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& L_C_LOGIN_ACCOUNT::name() const {
  // @@protoc_insertion_point(field_get:Protocol.L_C_LOGIN_ACCOUNT.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L_C_LOGIN_ACCOUNT::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.L_C_LOGIN_ACCOUNT.name)
}
inline std::string* L_C_LOGIN_ACCOUNT::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.L_C_LOGIN_ACCOUNT.name)
  return _s;
}
inline const std::string& L_C_LOGIN_ACCOUNT::_internal_name() const {
  return _impl_.name_.Get();
}
inline void L_C_LOGIN_ACCOUNT::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* L_C_LOGIN_ACCOUNT::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* L_C_LOGIN_ACCOUNT::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.L_C_LOGIN_ACCOUNT.name)
  return _impl_.name_.Release();
}
inline void L_C_LOGIN_ACCOUNT::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.L_C_LOGIN_ACCOUNT.name)
}

// string password = 2;
inline void L_C_LOGIN_ACCOUNT::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& L_C_LOGIN_ACCOUNT::password() const {
  // @@protoc_insertion_point(field_get:Protocol.L_C_LOGIN_ACCOUNT.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L_C_LOGIN_ACCOUNT::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.L_C_LOGIN_ACCOUNT.password)
}
inline std::string* L_C_LOGIN_ACCOUNT::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:Protocol.L_C_LOGIN_ACCOUNT.password)
  return _s;
}
inline const std::string& L_C_LOGIN_ACCOUNT::_internal_password() const {
  return _impl_.password_.Get();
}
inline void L_C_LOGIN_ACCOUNT::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* L_C_LOGIN_ACCOUNT::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* L_C_LOGIN_ACCOUNT::release_password() {
  // @@protoc_insertion_point(field_release:Protocol.L_C_LOGIN_ACCOUNT.password)
  return _impl_.password_.Release();
}
inline void L_C_LOGIN_ACCOUNT::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.L_C_LOGIN_ACCOUNT.password)
}

// -------------------------------------------------------------------

// L_S_LOGIN_ACCOUNT

// bool loginOk = 1;
inline void L_S_LOGIN_ACCOUNT::clear_loginok() {
  _impl_.loginok_ = false;
}
inline bool L_S_LOGIN_ACCOUNT::_internal_loginok() const {
  return _impl_.loginok_;
}
inline bool L_S_LOGIN_ACCOUNT::loginok() const {
  // @@protoc_insertion_point(field_get:Protocol.L_S_LOGIN_ACCOUNT.loginOk)
  return _internal_loginok();
}
inline void L_S_LOGIN_ACCOUNT::_internal_set_loginok(bool value) {
  
  _impl_.loginok_ = value;
}
inline void L_S_LOGIN_ACCOUNT::set_loginok(bool value) {
  _internal_set_loginok(value);
  // @@protoc_insertion_point(field_set:Protocol.L_S_LOGIN_ACCOUNT.loginOk)
}

// string loginFailedReason = 2;
inline void L_S_LOGIN_ACCOUNT::clear_loginfailedreason() {
  _impl_.loginfailedreason_.ClearToEmpty();
}
inline const std::string& L_S_LOGIN_ACCOUNT::loginfailedreason() const {
  // @@protoc_insertion_point(field_get:Protocol.L_S_LOGIN_ACCOUNT.loginFailedReason)
  return _internal_loginfailedreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L_S_LOGIN_ACCOUNT::set_loginfailedreason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginfailedreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.L_S_LOGIN_ACCOUNT.loginFailedReason)
}
inline std::string* L_S_LOGIN_ACCOUNT::mutable_loginfailedreason() {
  std::string* _s = _internal_mutable_loginfailedreason();
  // @@protoc_insertion_point(field_mutable:Protocol.L_S_LOGIN_ACCOUNT.loginFailedReason)
  return _s;
}
inline const std::string& L_S_LOGIN_ACCOUNT::_internal_loginfailedreason() const {
  return _impl_.loginfailedreason_.Get();
}
inline void L_S_LOGIN_ACCOUNT::_internal_set_loginfailedreason(const std::string& value) {
  
  _impl_.loginfailedreason_.Set(value, GetArenaForAllocation());
}
inline std::string* L_S_LOGIN_ACCOUNT::_internal_mutable_loginfailedreason() {
  
  return _impl_.loginfailedreason_.Mutable(GetArenaForAllocation());
}
inline std::string* L_S_LOGIN_ACCOUNT::release_loginfailedreason() {
  // @@protoc_insertion_point(field_release:Protocol.L_S_LOGIN_ACCOUNT.loginFailedReason)
  return _impl_.loginfailedreason_.Release();
}
inline void L_S_LOGIN_ACCOUNT::set_allocated_loginfailedreason(std::string* loginfailedreason) {
  if (loginfailedreason != nullptr) {
    
  } else {
    
  }
  _impl_.loginfailedreason_.SetAllocated(loginfailedreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginfailedreason_.IsDefault()) {
    _impl_.loginfailedreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.L_S_LOGIN_ACCOUNT.loginFailedReason)
}

// int32 accountId = 3;
inline void L_S_LOGIN_ACCOUNT::clear_accountid() {
  _impl_.accountid_ = 0;
}
inline int32_t L_S_LOGIN_ACCOUNT::_internal_accountid() const {
  return _impl_.accountid_;
}
inline int32_t L_S_LOGIN_ACCOUNT::accountid() const {
  // @@protoc_insertion_point(field_get:Protocol.L_S_LOGIN_ACCOUNT.accountId)
  return _internal_accountid();
}
inline void L_S_LOGIN_ACCOUNT::_internal_set_accountid(int32_t value) {
  
  _impl_.accountid_ = value;
}
inline void L_S_LOGIN_ACCOUNT::set_accountid(int32_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:Protocol.L_S_LOGIN_ACCOUNT.accountId)
}

// int32 token = 4;
inline void L_S_LOGIN_ACCOUNT::clear_token() {
  _impl_.token_ = 0;
}
inline int32_t L_S_LOGIN_ACCOUNT::_internal_token() const {
  return _impl_.token_;
}
inline int32_t L_S_LOGIN_ACCOUNT::token() const {
  // @@protoc_insertion_point(field_get:Protocol.L_S_LOGIN_ACCOUNT.token)
  return _internal_token();
}
inline void L_S_LOGIN_ACCOUNT::_internal_set_token(int32_t value) {
  
  _impl_.token_ = value;
}
inline void L_S_LOGIN_ACCOUNT::set_token(int32_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:Protocol.L_S_LOGIN_ACCOUNT.token)
}

// repeated .Protocol.ServerInfo serverInfos = 5;
inline int L_S_LOGIN_ACCOUNT::_internal_serverinfos_size() const {
  return _impl_.serverinfos_.size();
}
inline int L_S_LOGIN_ACCOUNT::serverinfos_size() const {
  return _internal_serverinfos_size();
}
inline ::Protocol::ServerInfo* L_S_LOGIN_ACCOUNT::mutable_serverinfos(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.L_S_LOGIN_ACCOUNT.serverInfos)
  return _impl_.serverinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ServerInfo >*
L_S_LOGIN_ACCOUNT::mutable_serverinfos() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.L_S_LOGIN_ACCOUNT.serverInfos)
  return &_impl_.serverinfos_;
}
inline const ::Protocol::ServerInfo& L_S_LOGIN_ACCOUNT::_internal_serverinfos(int index) const {
  return _impl_.serverinfos_.Get(index);
}
inline const ::Protocol::ServerInfo& L_S_LOGIN_ACCOUNT::serverinfos(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.L_S_LOGIN_ACCOUNT.serverInfos)
  return _internal_serverinfos(index);
}
inline ::Protocol::ServerInfo* L_S_LOGIN_ACCOUNT::_internal_add_serverinfos() {
  return _impl_.serverinfos_.Add();
}
inline ::Protocol::ServerInfo* L_S_LOGIN_ACCOUNT::add_serverinfos() {
  ::Protocol::ServerInfo* _add = _internal_add_serverinfos();
  // @@protoc_insertion_point(field_add:Protocol.L_S_LOGIN_ACCOUNT.serverInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ServerInfo >&
L_S_LOGIN_ACCOUNT::serverinfos() const {
  // @@protoc_insertion_point(field_list:Protocol.L_S_LOGIN_ACCOUNT.serverInfos)
  return _impl_.serverinfos_;
}

// -------------------------------------------------------------------

// S_CONNECTED

// string name = 1;
inline void S_CONNECTED::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& S_CONNECTED::name() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CONNECTED.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CONNECTED::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CONNECTED.name)
}
inline std::string* S_CONNECTED::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CONNECTED.name)
  return _s;
}
inline const std::string& S_CONNECTED::_internal_name() const {
  return _impl_.name_.Get();
}
inline void S_CONNECTED::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CONNECTED::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CONNECTED::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.S_CONNECTED.name)
  return _impl_.name_.Release();
}
inline void S_CONNECTED::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CONNECTED.name)
}

// -------------------------------------------------------------------

// C_LOGIN

// string uniqueId = 1;
inline void C_LOGIN::clear_uniqueid() {
  _impl_.uniqueid_.ClearToEmpty();
}
inline const std::string& C_LOGIN::uniqueid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.uniqueId)
  return _internal_uniqueid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_uniqueid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uniqueid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.uniqueId)
}
inline std::string* C_LOGIN::mutable_uniqueid() {
  std::string* _s = _internal_mutable_uniqueid();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.uniqueId)
  return _s;
}
inline const std::string& C_LOGIN::_internal_uniqueid() const {
  return _impl_.uniqueid_.Get();
}
inline void C_LOGIN::_internal_set_uniqueid(const std::string& value) {
  
  _impl_.uniqueid_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_uniqueid() {
  
  return _impl_.uniqueid_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_uniqueid() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.uniqueId)
  return _impl_.uniqueid_.Release();
}
inline void C_LOGIN::set_allocated_uniqueid(std::string* uniqueid) {
  if (uniqueid != nullptr) {
    
  } else {
    
  }
  _impl_.uniqueid_.SetAllocated(uniqueid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniqueid_.IsDefault()) {
    _impl_.uniqueid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.uniqueId)
}

// int32 token = 2;
inline void C_LOGIN::clear_token() {
  _impl_.token_ = 0;
}
inline int32_t C_LOGIN::_internal_token() const {
  return _impl_.token_;
}
inline int32_t C_LOGIN::token() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.token)
  return _internal_token();
}
inline void C_LOGIN::_internal_set_token(int32_t value) {
  
  _impl_.token_ = value;
}
inline void C_LOGIN::set_token(int32_t value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.token)
}

// int32 accountId = 3;
inline void C_LOGIN::clear_accountid() {
  _impl_.accountid_ = 0;
}
inline int32_t C_LOGIN::_internal_accountid() const {
  return _impl_.accountid_;
}
inline int32_t C_LOGIN::accountid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.accountId)
  return _internal_accountid();
}
inline void C_LOGIN::_internal_set_accountid(int32_t value) {
  
  _impl_.accountid_ = value;
}
inline void C_LOGIN::set_accountid(int32_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.accountId)
}

// -------------------------------------------------------------------

// S_LOGIN

// int32 loginOk = 1;
inline void S_LOGIN::clear_loginok() {
  _impl_.loginok_ = 0;
}
inline int32_t S_LOGIN::_internal_loginok() const {
  return _impl_.loginok_;
}
inline int32_t S_LOGIN::loginok() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.loginOk)
  return _internal_loginok();
}
inline void S_LOGIN::_internal_set_loginok(int32_t value) {
  
  _impl_.loginok_ = value;
}
inline void S_LOGIN::set_loginok(int32_t value) {
  _internal_set_loginok(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.loginOk)
}

// repeated .Protocol.LobbyPlayerInfo lobbyPlayers = 2;
inline int S_LOGIN::_internal_lobbyplayers_size() const {
  return _impl_.lobbyplayers_.size();
}
inline int S_LOGIN::lobbyplayers_size() const {
  return _internal_lobbyplayers_size();
}
inline ::Protocol::LobbyPlayerInfo* S_LOGIN::mutable_lobbyplayers(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_LOGIN.lobbyPlayers)
  return _impl_.lobbyplayers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >*
S_LOGIN::mutable_lobbyplayers() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOGIN.lobbyPlayers)
  return &_impl_.lobbyplayers_;
}
inline const ::Protocol::LobbyPlayerInfo& S_LOGIN::_internal_lobbyplayers(int index) const {
  return _impl_.lobbyplayers_.Get(index);
}
inline const ::Protocol::LobbyPlayerInfo& S_LOGIN::lobbyplayers(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.lobbyPlayers)
  return _internal_lobbyplayers(index);
}
inline ::Protocol::LobbyPlayerInfo* S_LOGIN::_internal_add_lobbyplayers() {
  return _impl_.lobbyplayers_.Add();
}
inline ::Protocol::LobbyPlayerInfo* S_LOGIN::add_lobbyplayers() {
  ::Protocol::LobbyPlayerInfo* _add = _internal_add_lobbyplayers();
  // @@protoc_insertion_point(field_add:Protocol.S_LOGIN.lobbyPlayers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::LobbyPlayerInfo >&
S_LOGIN::lobbyplayers() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOGIN.lobbyPlayers)
  return _impl_.lobbyplayers_;
}

// -------------------------------------------------------------------

// C_CREATE_PLAYER

// string name = 1;
inline void C_CREATE_PLAYER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& C_CREATE_PLAYER::name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATE_PLAYER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CREATE_PLAYER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CREATE_PLAYER.name)
}
inline std::string* C_CREATE_PLAYER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CREATE_PLAYER.name)
  return _s;
}
inline const std::string& C_CREATE_PLAYER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void C_CREATE_PLAYER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CREATE_PLAYER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CREATE_PLAYER::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_CREATE_PLAYER.name)
  return _impl_.name_.Release();
}
inline void C_CREATE_PLAYER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CREATE_PLAYER.name)
}

// -------------------------------------------------------------------

// S_CREATE_PLAYER

// int32 createOk = 1;
inline void S_CREATE_PLAYER::clear_createok() {
  _impl_.createok_ = 0;
}
inline int32_t S_CREATE_PLAYER::_internal_createok() const {
  return _impl_.createok_;
}
inline int32_t S_CREATE_PLAYER::createok() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CREATE_PLAYER.createOk)
  return _internal_createok();
}
inline void S_CREATE_PLAYER::_internal_set_createok(int32_t value) {
  
  _impl_.createok_ = value;
}
inline void S_CREATE_PLAYER::set_createok(int32_t value) {
  _internal_set_createok(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CREATE_PLAYER.createOk)
}

// .Protocol.LobbyPlayerInfo createPlayer = 2;
inline bool S_CREATE_PLAYER::_internal_has_createplayer() const {
  return this != internal_default_instance() && _impl_.createplayer_ != nullptr;
}
inline bool S_CREATE_PLAYER::has_createplayer() const {
  return _internal_has_createplayer();
}
inline const ::Protocol::LobbyPlayerInfo& S_CREATE_PLAYER::_internal_createplayer() const {
  const ::Protocol::LobbyPlayerInfo* p = _impl_.createplayer_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::LobbyPlayerInfo&>(
      ::Protocol::_LobbyPlayerInfo_default_instance_);
}
inline const ::Protocol::LobbyPlayerInfo& S_CREATE_PLAYER::createplayer() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CREATE_PLAYER.createPlayer)
  return _internal_createplayer();
}
inline void S_CREATE_PLAYER::unsafe_arena_set_allocated_createplayer(
    ::Protocol::LobbyPlayerInfo* createplayer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createplayer_);
  }
  _impl_.createplayer_ = createplayer;
  if (createplayer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_CREATE_PLAYER.createPlayer)
}
inline ::Protocol::LobbyPlayerInfo* S_CREATE_PLAYER::release_createplayer() {
  
  ::Protocol::LobbyPlayerInfo* temp = _impl_.createplayer_;
  _impl_.createplayer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::LobbyPlayerInfo* S_CREATE_PLAYER::unsafe_arena_release_createplayer() {
  // @@protoc_insertion_point(field_release:Protocol.S_CREATE_PLAYER.createPlayer)
  
  ::Protocol::LobbyPlayerInfo* temp = _impl_.createplayer_;
  _impl_.createplayer_ = nullptr;
  return temp;
}
inline ::Protocol::LobbyPlayerInfo* S_CREATE_PLAYER::_internal_mutable_createplayer() {
  
  if (_impl_.createplayer_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::LobbyPlayerInfo>(GetArenaForAllocation());
    _impl_.createplayer_ = p;
  }
  return _impl_.createplayer_;
}
inline ::Protocol::LobbyPlayerInfo* S_CREATE_PLAYER::mutable_createplayer() {
  ::Protocol::LobbyPlayerInfo* _msg = _internal_mutable_createplayer();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CREATE_PLAYER.createPlayer)
  return _msg;
}
inline void S_CREATE_PLAYER::set_allocated_createplayer(::Protocol::LobbyPlayerInfo* createplayer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createplayer_);
  }
  if (createplayer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createplayer));
    if (message_arena != submessage_arena) {
      createplayer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createplayer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.createplayer_ = createplayer;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CREATE_PLAYER.createPlayer)
}

// -------------------------------------------------------------------

// C_ENTER_GAME

// string name = 1;
inline void C_ENTER_GAME::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& C_ENTER_GAME::name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_ENTER_GAME::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_GAME.name)
}
inline std::string* C_ENTER_GAME::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_ENTER_GAME.name)
  return _s;
}
inline const std::string& C_ENTER_GAME::_internal_name() const {
  return _impl_.name_.Get();
}
inline void C_ENTER_GAME::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_ENTER_GAME::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_ENTER_GAME::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_ENTER_GAME.name)
  return _impl_.name_.Release();
}
inline void C_ENTER_GAME::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ENTER_GAME.name)
}

// -------------------------------------------------------------------

// S_ENTER_GAME

// .Protocol.ActorInfo player = 1;
inline bool S_ENTER_GAME::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_ENTER_GAME::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ActorInfo& S_ENTER_GAME::_internal_player() const {
  const ::Protocol::ActorInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ActorInfo&>(
      ::Protocol::_ActorInfo_default_instance_);
}
inline const ::Protocol::ActorInfo& S_ENTER_GAME::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.player)
  return _internal_player();
}
inline void S_ENTER_GAME::unsafe_arena_set_allocated_player(
    ::Protocol::ActorInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_GAME.player)
}
inline ::Protocol::ActorInfo* S_ENTER_GAME::release_player() {
  
  ::Protocol::ActorInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ActorInfo* S_ENTER_GAME::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_GAME.player)
  
  ::Protocol::ActorInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::ActorInfo* S_ENTER_GAME::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ActorInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::ActorInfo* S_ENTER_GAME::mutable_player() {
  ::Protocol::ActorInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.player)
  return _msg;
}
inline void S_ENTER_GAME::set_allocated_player(::Protocol::ActorInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_GAME.player)
}

// -------------------------------------------------------------------

// S_LEAVE_GAME

// -------------------------------------------------------------------

// S_ITEM_LIST

// repeated .Protocol.ItemInfo itemInfos = 1;
inline int S_ITEM_LIST::_internal_iteminfos_size() const {
  return _impl_.iteminfos_.size();
}
inline int S_ITEM_LIST::iteminfos_size() const {
  return _internal_iteminfos_size();
}
inline ::Protocol::ItemInfo* S_ITEM_LIST::mutable_iteminfos(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ITEM_LIST.itemInfos)
  return _impl_.iteminfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_ITEM_LIST::mutable_iteminfos() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ITEM_LIST.itemInfos)
  return &_impl_.iteminfos_;
}
inline const ::Protocol::ItemInfo& S_ITEM_LIST::_internal_iteminfos(int index) const {
  return _impl_.iteminfos_.Get(index);
}
inline const ::Protocol::ItemInfo& S_ITEM_LIST::iteminfos(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ITEM_LIST.itemInfos)
  return _internal_iteminfos(index);
}
inline ::Protocol::ItemInfo* S_ITEM_LIST::_internal_add_iteminfos() {
  return _impl_.iteminfos_.Add();
}
inline ::Protocol::ItemInfo* S_ITEM_LIST::add_iteminfos() {
  ::Protocol::ItemInfo* _add = _internal_add_iteminfos();
  // @@protoc_insertion_point(field_add:Protocol.S_ITEM_LIST.itemInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_ITEM_LIST::iteminfos() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ITEM_LIST.itemInfos)
  return _impl_.iteminfos_;
}

// -------------------------------------------------------------------

// S_ADD_ITEM

// repeated .Protocol.ItemInfo itemInfos = 1;
inline int S_ADD_ITEM::_internal_iteminfos_size() const {
  return _impl_.iteminfos_.size();
}
inline int S_ADD_ITEM::iteminfos_size() const {
  return _internal_iteminfos_size();
}
inline ::Protocol::ItemInfo* S_ADD_ITEM::mutable_iteminfos(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ADD_ITEM.itemInfos)
  return _impl_.iteminfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >*
S_ADD_ITEM::mutable_iteminfos() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ADD_ITEM.itemInfos)
  return &_impl_.iteminfos_;
}
inline const ::Protocol::ItemInfo& S_ADD_ITEM::_internal_iteminfos(int index) const {
  return _impl_.iteminfos_.Get(index);
}
inline const ::Protocol::ItemInfo& S_ADD_ITEM::iteminfos(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ADD_ITEM.itemInfos)
  return _internal_iteminfos(index);
}
inline ::Protocol::ItemInfo* S_ADD_ITEM::_internal_add_iteminfos() {
  return _impl_.iteminfos_.Add();
}
inline ::Protocol::ItemInfo* S_ADD_ITEM::add_iteminfos() {
  ::Protocol::ItemInfo* _add = _internal_add_iteminfos();
  // @@protoc_insertion_point(field_add:Protocol.S_ADD_ITEM.itemInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ItemInfo >&
S_ADD_ITEM::iteminfos() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ADD_ITEM.itemInfos)
  return _impl_.iteminfos_;
}

// -------------------------------------------------------------------

// C_EQUIP_ITEM

// int32 itemDbId = 1;
inline void C_EQUIP_ITEM::clear_itemdbid() {
  _impl_.itemdbid_ = 0;
}
inline int32_t C_EQUIP_ITEM::_internal_itemdbid() const {
  return _impl_.itemdbid_;
}
inline int32_t C_EQUIP_ITEM::itemdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EQUIP_ITEM.itemDbId)
  return _internal_itemdbid();
}
inline void C_EQUIP_ITEM::_internal_set_itemdbid(int32_t value) {
  
  _impl_.itemdbid_ = value;
}
inline void C_EQUIP_ITEM::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EQUIP_ITEM.itemDbId)
}

// bool equipped = 2;
inline void C_EQUIP_ITEM::clear_equipped() {
  _impl_.equipped_ = false;
}
inline bool C_EQUIP_ITEM::_internal_equipped() const {
  return _impl_.equipped_;
}
inline bool C_EQUIP_ITEM::equipped() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EQUIP_ITEM.equipped)
  return _internal_equipped();
}
inline void C_EQUIP_ITEM::_internal_set_equipped(bool value) {
  
  _impl_.equipped_ = value;
}
inline void C_EQUIP_ITEM::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EQUIP_ITEM.equipped)
}

// -------------------------------------------------------------------

// S_EQUIP_ITEM

// int32 itemDbId = 1;
inline void S_EQUIP_ITEM::clear_itemdbid() {
  _impl_.itemdbid_ = 0;
}
inline int32_t S_EQUIP_ITEM::_internal_itemdbid() const {
  return _impl_.itemdbid_;
}
inline int32_t S_EQUIP_ITEM::itemdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EQUIP_ITEM.itemDbId)
  return _internal_itemdbid();
}
inline void S_EQUIP_ITEM::_internal_set_itemdbid(int32_t value) {
  
  _impl_.itemdbid_ = value;
}
inline void S_EQUIP_ITEM::set_itemdbid(int32_t value) {
  _internal_set_itemdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EQUIP_ITEM.itemDbId)
}

// bool equipped = 2;
inline void S_EQUIP_ITEM::clear_equipped() {
  _impl_.equipped_ = false;
}
inline bool S_EQUIP_ITEM::_internal_equipped() const {
  return _impl_.equipped_;
}
inline bool S_EQUIP_ITEM::equipped() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EQUIP_ITEM.equipped)
  return _internal_equipped();
}
inline void S_EQUIP_ITEM::_internal_set_equipped(bool value) {
  
  _impl_.equipped_ = value;
}
inline void S_EQUIP_ITEM::set_equipped(bool value) {
  _internal_set_equipped(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EQUIP_ITEM.equipped)
}

// -------------------------------------------------------------------

// S_SPAWN

// repeated .Protocol.ActorInfo actors = 1;
inline int S_SPAWN::_internal_actors_size() const {
  return _impl_.actors_.size();
}
inline int S_SPAWN::actors_size() const {
  return _internal_actors_size();
}
inline ::Protocol::ActorInfo* S_SPAWN::mutable_actors(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.actors)
  return _impl_.actors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo >*
S_SPAWN::mutable_actors() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.actors)
  return &_impl_.actors_;
}
inline const ::Protocol::ActorInfo& S_SPAWN::_internal_actors(int index) const {
  return _impl_.actors_.Get(index);
}
inline const ::Protocol::ActorInfo& S_SPAWN::actors(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.actors)
  return _internal_actors(index);
}
inline ::Protocol::ActorInfo* S_SPAWN::_internal_add_actors() {
  return _impl_.actors_.Add();
}
inline ::Protocol::ActorInfo* S_SPAWN::add_actors() {
  ::Protocol::ActorInfo* _add = _internal_add_actors();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.actors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo >&
S_SPAWN::actors() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.actors)
  return _impl_.actors_;
}

// -------------------------------------------------------------------

// S_DESPAWN

// repeated int32 actorId = 1;
inline int S_DESPAWN::_internal_actorid_size() const {
  return _impl_.actorid_.size();
}
inline int S_DESPAWN::actorid_size() const {
  return _internal_actorid_size();
}
inline void S_DESPAWN::clear_actorid() {
  _impl_.actorid_.Clear();
}
inline int32_t S_DESPAWN::_internal_actorid(int index) const {
  return _impl_.actorid_.Get(index);
}
inline int32_t S_DESPAWN::actorid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_DESPAWN.actorId)
  return _internal_actorid(index);
}
inline void S_DESPAWN::set_actorid(int index, int32_t value) {
  _impl_.actorid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_DESPAWN.actorId)
}
inline void S_DESPAWN::_internal_add_actorid(int32_t value) {
  _impl_.actorid_.Add(value);
}
inline void S_DESPAWN::add_actorid(int32_t value) {
  _internal_add_actorid(value);
  // @@protoc_insertion_point(field_add:Protocol.S_DESPAWN.actorId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_DESPAWN::_internal_actorid() const {
  return _impl_.actorid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_DESPAWN::actorid() const {
  // @@protoc_insertion_point(field_list:Protocol.S_DESPAWN.actorId)
  return _internal_actorid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_DESPAWN::_internal_mutable_actorid() {
  return &_impl_.actorid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_DESPAWN::mutable_actorid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_DESPAWN.actorId)
  return _internal_mutable_actorid();
}

// -------------------------------------------------------------------

// C_MOVE

// .Protocol.PositionInfo positionInfo = 1;
inline bool C_MOVE::_internal_has_positioninfo() const {
  return this != internal_default_instance() && _impl_.positioninfo_ != nullptr;
}
inline bool C_MOVE::has_positioninfo() const {
  return _internal_has_positioninfo();
}
inline const ::Protocol::PositionInfo& C_MOVE::_internal_positioninfo() const {
  const ::Protocol::PositionInfo* p = _impl_.positioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& C_MOVE::positioninfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.positionInfo)
  return _internal_positioninfo();
}
inline void C_MOVE::unsafe_arena_set_allocated_positioninfo(
    ::Protocol::PositionInfo* positioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positioninfo_);
  }
  _impl_.positioninfo_ = positioninfo;
  if (positioninfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MOVE.positionInfo)
}
inline ::Protocol::PositionInfo* C_MOVE::release_positioninfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.positioninfo_;
  _impl_.positioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* C_MOVE::unsafe_arena_release_positioninfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_MOVE.positionInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.positioninfo_;
  _impl_.positioninfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* C_MOVE::_internal_mutable_positioninfo() {
  
  if (_impl_.positioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.positioninfo_ = p;
  }
  return _impl_.positioninfo_;
}
inline ::Protocol::PositionInfo* C_MOVE::mutable_positioninfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_positioninfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_MOVE.positionInfo)
  return _msg;
}
inline void C_MOVE::set_allocated_positioninfo(::Protocol::PositionInfo* positioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positioninfo_);
  }
  if (positioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positioninfo));
    if (message_arena != submessage_arena) {
      positioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positioninfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.positioninfo_ = positioninfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MOVE.positionInfo)
}

// -------------------------------------------------------------------

// S_MOVE

// int32 actorId = 1;
inline void S_MOVE::clear_actorid() {
  _impl_.actorid_ = 0;
}
inline int32_t S_MOVE::_internal_actorid() const {
  return _impl_.actorid_;
}
inline int32_t S_MOVE::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.actorId)
  return _internal_actorid();
}
inline void S_MOVE::_internal_set_actorid(int32_t value) {
  
  _impl_.actorid_ = value;
}
inline void S_MOVE::set_actorid(int32_t value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_MOVE.actorId)
}

// .Protocol.PositionInfo positionInfo = 2;
inline bool S_MOVE::_internal_has_positioninfo() const {
  return this != internal_default_instance() && _impl_.positioninfo_ != nullptr;
}
inline bool S_MOVE::has_positioninfo() const {
  return _internal_has_positioninfo();
}
inline const ::Protocol::PositionInfo& S_MOVE::_internal_positioninfo() const {
  const ::Protocol::PositionInfo* p = _impl_.positioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& S_MOVE::positioninfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.positionInfo)
  return _internal_positioninfo();
}
inline void S_MOVE::unsafe_arena_set_allocated_positioninfo(
    ::Protocol::PositionInfo* positioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positioninfo_);
  }
  _impl_.positioninfo_ = positioninfo;
  if (positioninfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.positionInfo)
}
inline ::Protocol::PositionInfo* S_MOVE::release_positioninfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.positioninfo_;
  _impl_.positioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* S_MOVE::unsafe_arena_release_positioninfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.positionInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.positioninfo_;
  _impl_.positioninfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* S_MOVE::_internal_mutable_positioninfo() {
  
  if (_impl_.positioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.positioninfo_ = p;
  }
  return _impl_.positioninfo_;
}
inline ::Protocol::PositionInfo* S_MOVE::mutable_positioninfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_positioninfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.positionInfo)
  return _msg;
}
inline void S_MOVE::set_allocated_positioninfo(::Protocol::PositionInfo* positioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positioninfo_);
  }
  if (positioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positioninfo));
    if (message_arena != submessage_arena) {
      positioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positioninfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.positioninfo_ = positioninfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.positionInfo)
}

// -------------------------------------------------------------------

// C_SKILL

// .Protocol.SkillInfo skillInfo = 1;
inline bool C_SKILL::_internal_has_skillinfo() const {
  return this != internal_default_instance() && _impl_.skillinfo_ != nullptr;
}
inline bool C_SKILL::has_skillinfo() const {
  return _internal_has_skillinfo();
}
inline const ::Protocol::SkillInfo& C_SKILL::_internal_skillinfo() const {
  const ::Protocol::SkillInfo* p = _impl_.skillinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SkillInfo&>(
      ::Protocol::_SkillInfo_default_instance_);
}
inline const ::Protocol::SkillInfo& C_SKILL::skillinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SKILL.skillInfo)
  return _internal_skillinfo();
}
inline void C_SKILL::unsafe_arena_set_allocated_skillinfo(
    ::Protocol::SkillInfo* skillinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skillinfo_);
  }
  _impl_.skillinfo_ = skillinfo;
  if (skillinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_SKILL.skillInfo)
}
inline ::Protocol::SkillInfo* C_SKILL::release_skillinfo() {
  
  ::Protocol::SkillInfo* temp = _impl_.skillinfo_;
  _impl_.skillinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SkillInfo* C_SKILL::unsafe_arena_release_skillinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_SKILL.skillInfo)
  
  ::Protocol::SkillInfo* temp = _impl_.skillinfo_;
  _impl_.skillinfo_ = nullptr;
  return temp;
}
inline ::Protocol::SkillInfo* C_SKILL::_internal_mutable_skillinfo() {
  
  if (_impl_.skillinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SkillInfo>(GetArenaForAllocation());
    _impl_.skillinfo_ = p;
  }
  return _impl_.skillinfo_;
}
inline ::Protocol::SkillInfo* C_SKILL::mutable_skillinfo() {
  ::Protocol::SkillInfo* _msg = _internal_mutable_skillinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_SKILL.skillInfo)
  return _msg;
}
inline void C_SKILL::set_allocated_skillinfo(::Protocol::SkillInfo* skillinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skillinfo_);
  }
  if (skillinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(skillinfo));
    if (message_arena != submessage_arena) {
      skillinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skillinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.skillinfo_ = skillinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_SKILL.skillInfo)
}

// -------------------------------------------------------------------

// S_SKILL

// int32 actorId = 1;
inline void S_SKILL::clear_actorid() {
  _impl_.actorid_ = 0;
}
inline int32_t S_SKILL::_internal_actorid() const {
  return _impl_.actorid_;
}
inline int32_t S_SKILL::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.actorId)
  return _internal_actorid();
}
inline void S_SKILL::_internal_set_actorid(int32_t value) {
  
  _impl_.actorid_ = value;
}
inline void S_SKILL::set_actorid(int32_t value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SKILL.actorId)
}

// .Protocol.SkillInfo skillInfo = 2;
inline bool S_SKILL::_internal_has_skillinfo() const {
  return this != internal_default_instance() && _impl_.skillinfo_ != nullptr;
}
inline bool S_SKILL::has_skillinfo() const {
  return _internal_has_skillinfo();
}
inline const ::Protocol::SkillInfo& S_SKILL::_internal_skillinfo() const {
  const ::Protocol::SkillInfo* p = _impl_.skillinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SkillInfo&>(
      ::Protocol::_SkillInfo_default_instance_);
}
inline const ::Protocol::SkillInfo& S_SKILL::skillinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SKILL.skillInfo)
  return _internal_skillinfo();
}
inline void S_SKILL::unsafe_arena_set_allocated_skillinfo(
    ::Protocol::SkillInfo* skillinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skillinfo_);
  }
  _impl_.skillinfo_ = skillinfo;
  if (skillinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_SKILL.skillInfo)
}
inline ::Protocol::SkillInfo* S_SKILL::release_skillinfo() {
  
  ::Protocol::SkillInfo* temp = _impl_.skillinfo_;
  _impl_.skillinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SkillInfo* S_SKILL::unsafe_arena_release_skillinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_SKILL.skillInfo)
  
  ::Protocol::SkillInfo* temp = _impl_.skillinfo_;
  _impl_.skillinfo_ = nullptr;
  return temp;
}
inline ::Protocol::SkillInfo* S_SKILL::_internal_mutable_skillinfo() {
  
  if (_impl_.skillinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SkillInfo>(GetArenaForAllocation());
    _impl_.skillinfo_ = p;
  }
  return _impl_.skillinfo_;
}
inline ::Protocol::SkillInfo* S_SKILL::mutable_skillinfo() {
  ::Protocol::SkillInfo* _msg = _internal_mutable_skillinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_SKILL.skillInfo)
  return _msg;
}
inline void S_SKILL::set_allocated_skillinfo(::Protocol::SkillInfo* skillinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.skillinfo_);
  }
  if (skillinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(skillinfo));
    if (message_arena != submessage_arena) {
      skillinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skillinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.skillinfo_ = skillinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_SKILL.skillInfo)
}

// -------------------------------------------------------------------

// S_CHANGE_HP

// int32 actorId = 1;
inline void S_CHANGE_HP::clear_actorid() {
  _impl_.actorid_ = 0;
}
inline int32_t S_CHANGE_HP::_internal_actorid() const {
  return _impl_.actorid_;
}
inline int32_t S_CHANGE_HP::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_HP.actorId)
  return _internal_actorid();
}
inline void S_CHANGE_HP::_internal_set_actorid(int32_t value) {
  
  _impl_.actorid_ = value;
}
inline void S_CHANGE_HP::set_actorid(int32_t value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_HP.actorId)
}

// int32 hp = 2;
inline void S_CHANGE_HP::clear_hp() {
  _impl_.hp_ = 0;
}
inline int32_t S_CHANGE_HP::_internal_hp() const {
  return _impl_.hp_;
}
inline int32_t S_CHANGE_HP::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_HP.hp)
  return _internal_hp();
}
inline void S_CHANGE_HP::_internal_set_hp(int32_t value) {
  
  _impl_.hp_ = value;
}
inline void S_CHANGE_HP::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_HP.hp)
}

// -------------------------------------------------------------------

// S_CHANGE_STAT

// .Protocol.StatInfo statInfo = 1;
inline bool S_CHANGE_STAT::_internal_has_statinfo() const {
  return this != internal_default_instance() && _impl_.statinfo_ != nullptr;
}
inline bool S_CHANGE_STAT::has_statinfo() const {
  return _internal_has_statinfo();
}
inline const ::Protocol::StatInfo& S_CHANGE_STAT::_internal_statinfo() const {
  const ::Protocol::StatInfo* p = _impl_.statinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& S_CHANGE_STAT::statinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_STAT.statInfo)
  return _internal_statinfo();
}
inline void S_CHANGE_STAT::unsafe_arena_set_allocated_statinfo(
    ::Protocol::StatInfo* statinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statinfo_);
  }
  _impl_.statinfo_ = statinfo;
  if (statinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_CHANGE_STAT.statInfo)
}
inline ::Protocol::StatInfo* S_CHANGE_STAT::release_statinfo() {
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatInfo* S_CHANGE_STAT::unsafe_arena_release_statinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHANGE_STAT.statInfo)
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* S_CHANGE_STAT::_internal_mutable_statinfo() {
  
  if (_impl_.statinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    _impl_.statinfo_ = p;
  }
  return _impl_.statinfo_;
}
inline ::Protocol::StatInfo* S_CHANGE_STAT::mutable_statinfo() {
  ::Protocol::StatInfo* _msg = _internal_mutable_statinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHANGE_STAT.statInfo)
  return _msg;
}
inline void S_CHANGE_STAT::set_allocated_statinfo(::Protocol::StatInfo* statinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statinfo_);
  }
  if (statinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statinfo));
    if (message_arena != submessage_arena) {
      statinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statinfo_ = statinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHANGE_STAT.statInfo)
}

// -------------------------------------------------------------------

// S_DEATH

// int32 actorId = 1;
inline void S_DEATH::clear_actorid() {
  _impl_.actorid_ = 0;
}
inline int32_t S_DEATH::_internal_actorid() const {
  return _impl_.actorid_;
}
inline int32_t S_DEATH::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DEATH.actorId)
  return _internal_actorid();
}
inline void S_DEATH::_internal_set_actorid(int32_t value) {
  
  _impl_.actorid_ = value;
}
inline void S_DEATH::set_actorid(int32_t value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DEATH.actorId)
}

// int32 attackerId = 2;
inline void S_DEATH::clear_attackerid() {
  _impl_.attackerid_ = 0;
}
inline int32_t S_DEATH::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline int32_t S_DEATH::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DEATH.attackerId)
  return _internal_attackerid();
}
inline void S_DEATH::_internal_set_attackerid(int32_t value) {
  
  _impl_.attackerid_ = value;
}
inline void S_DEATH::set_attackerid(int32_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DEATH.attackerId)
}

// -------------------------------------------------------------------

// C_CHANGE_STATE

// .Protocol.AIState state = 1;
inline void C_CHANGE_STATE::clear_state() {
  _impl_.state_ = 0;
}
inline ::Protocol::AIState C_CHANGE_STATE::_internal_state() const {
  return static_cast< ::Protocol::AIState >(_impl_.state_);
}
inline ::Protocol::AIState C_CHANGE_STATE::state() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHANGE_STATE.state)
  return _internal_state();
}
inline void C_CHANGE_STATE::_internal_set_state(::Protocol::AIState value) {
  
  _impl_.state_ = value;
}
inline void C_CHANGE_STATE::set_state(::Protocol::AIState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CHANGE_STATE.state)
}

// -------------------------------------------------------------------

// S_CHANGE_STATE

// int32 actorId = 1;
inline void S_CHANGE_STATE::clear_actorid() {
  _impl_.actorid_ = 0;
}
inline int32_t S_CHANGE_STATE::_internal_actorid() const {
  return _impl_.actorid_;
}
inline int32_t S_CHANGE_STATE::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_STATE.actorId)
  return _internal_actorid();
}
inline void S_CHANGE_STATE::_internal_set_actorid(int32_t value) {
  
  _impl_.actorid_ = value;
}
inline void S_CHANGE_STATE::set_actorid(int32_t value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_STATE.actorId)
}

// .Protocol.AIState state = 2;
inline void S_CHANGE_STATE::clear_state() {
  _impl_.state_ = 0;
}
inline ::Protocol::AIState S_CHANGE_STATE::_internal_state() const {
  return static_cast< ::Protocol::AIState >(_impl_.state_);
}
inline ::Protocol::AIState S_CHANGE_STATE::state() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_STATE.state)
  return _internal_state();
}
inline void S_CHANGE_STATE::_internal_set_state(::Protocol::AIState value) {
  
  _impl_.state_ = value;
}
inline void S_CHANGE_STATE::set_state(::Protocol::AIState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_STATE.state)
}

// -------------------------------------------------------------------

// C_CHANGE_MOVE_DIR

// .Protocol.MoveDir moveDir = 2;
inline void C_CHANGE_MOVE_DIR::clear_movedir() {
  _impl_.movedir_ = 0;
}
inline ::Protocol::MoveDir C_CHANGE_MOVE_DIR::_internal_movedir() const {
  return static_cast< ::Protocol::MoveDir >(_impl_.movedir_);
}
inline ::Protocol::MoveDir C_CHANGE_MOVE_DIR::movedir() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHANGE_MOVE_DIR.moveDir)
  return _internal_movedir();
}
inline void C_CHANGE_MOVE_DIR::_internal_set_movedir(::Protocol::MoveDir value) {
  
  _impl_.movedir_ = value;
}
inline void C_CHANGE_MOVE_DIR::set_movedir(::Protocol::MoveDir value) {
  _internal_set_movedir(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CHANGE_MOVE_DIR.moveDir)
}

// -------------------------------------------------------------------

// S_CHANGE_MOVE_DIR

// int32 actorId = 1;
inline void S_CHANGE_MOVE_DIR::clear_actorid() {
  _impl_.actorid_ = 0;
}
inline int32_t S_CHANGE_MOVE_DIR::_internal_actorid() const {
  return _impl_.actorid_;
}
inline int32_t S_CHANGE_MOVE_DIR::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_MOVE_DIR.actorId)
  return _internal_actorid();
}
inline void S_CHANGE_MOVE_DIR::_internal_set_actorid(int32_t value) {
  
  _impl_.actorid_ = value;
}
inline void S_CHANGE_MOVE_DIR::set_actorid(int32_t value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_MOVE_DIR.actorId)
}

// .Protocol.MoveDir moveDir = 2;
inline void S_CHANGE_MOVE_DIR::clear_movedir() {
  _impl_.movedir_ = 0;
}
inline ::Protocol::MoveDir S_CHANGE_MOVE_DIR::_internal_movedir() const {
  return static_cast< ::Protocol::MoveDir >(_impl_.movedir_);
}
inline ::Protocol::MoveDir S_CHANGE_MOVE_DIR::movedir() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHANGE_MOVE_DIR.moveDir)
  return _internal_movedir();
}
inline void S_CHANGE_MOVE_DIR::_internal_set_movedir(::Protocol::MoveDir value) {
  
  _impl_.movedir_ = value;
}
inline void S_CHANGE_MOVE_DIR::set_movedir(::Protocol::MoveDir value) {
  _internal_set_movedir(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHANGE_MOVE_DIR.moveDir)
}

// -------------------------------------------------------------------

// C_CHAT

// string chat = 1;
inline void C_CHAT::clear_chat() {
  _impl_.chat_.ClearToEmpty();
}
inline const std::string& C_CHAT::chat() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_chat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.chat)
}
inline std::string* C_CHAT::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHAT.chat)
  return _s;
}
inline const std::string& C_CHAT::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void C_CHAT::_internal_set_chat(const std::string& value) {
  
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_chat() {
  
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CHAT::release_chat() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHAT.chat)
  return _impl_.chat_.Release();
}
inline void C_CHAT::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    
  } else {
    
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHAT.chat)
}

// -------------------------------------------------------------------

// S_CHAT

// int32 actorId = 1;
inline void S_CHAT::clear_actorid() {
  _impl_.actorid_ = 0;
}
inline int32_t S_CHAT::_internal_actorid() const {
  return _impl_.actorid_;
}
inline int32_t S_CHAT::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.actorId)
  return _internal_actorid();
}
inline void S_CHAT::_internal_set_actorid(int32_t value) {
  
  _impl_.actorid_ = value;
}
inline void S_CHAT::set_actorid(int32_t value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.actorId)
}

// string chat = 2;
inline void S_CHAT::clear_chat() {
  _impl_.chat_.ClearToEmpty();
}
inline const std::string& S_CHAT::chat() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.chat)
  return _internal_chat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_chat(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chat_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.chat)
}
inline std::string* S_CHAT::mutable_chat() {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.chat)
  return _s;
}
inline const std::string& S_CHAT::_internal_chat() const {
  return _impl_.chat_.Get();
}
inline void S_CHAT::_internal_set_chat(const std::string& value) {
  
  _impl_.chat_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_chat() {
  
  return _impl_.chat_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_chat() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.chat)
  return _impl_.chat_.Release();
}
inline void S_CHAT::set_allocated_chat(std::string* chat) {
  if (chat != nullptr) {
    
  } else {
    
  }
  _impl_.chat_.SetAllocated(chat, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chat_.IsDefault()) {
    _impl_.chat_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.chat)
}

// -------------------------------------------------------------------

// S_PING

// -------------------------------------------------------------------

// C_PONG

// -------------------------------------------------------------------

// C_POSITION

// .Protocol.PositionInfo positionInfo = 1;
inline bool C_POSITION::_internal_has_positioninfo() const {
  return this != internal_default_instance() && _impl_.positioninfo_ != nullptr;
}
inline bool C_POSITION::has_positioninfo() const {
  return _internal_has_positioninfo();
}
inline const ::Protocol::PositionInfo& C_POSITION::_internal_positioninfo() const {
  const ::Protocol::PositionInfo* p = _impl_.positioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& C_POSITION::positioninfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_POSITION.positionInfo)
  return _internal_positioninfo();
}
inline void C_POSITION::unsafe_arena_set_allocated_positioninfo(
    ::Protocol::PositionInfo* positioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positioninfo_);
  }
  _impl_.positioninfo_ = positioninfo;
  if (positioninfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_POSITION.positionInfo)
}
inline ::Protocol::PositionInfo* C_POSITION::release_positioninfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.positioninfo_;
  _impl_.positioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* C_POSITION::unsafe_arena_release_positioninfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_POSITION.positionInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.positioninfo_;
  _impl_.positioninfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* C_POSITION::_internal_mutable_positioninfo() {
  
  if (_impl_.positioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.positioninfo_ = p;
  }
  return _impl_.positioninfo_;
}
inline ::Protocol::PositionInfo* C_POSITION::mutable_positioninfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_positioninfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_POSITION.positionInfo)
  return _msg;
}
inline void C_POSITION::set_allocated_positioninfo(::Protocol::PositionInfo* positioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positioninfo_);
  }
  if (positioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positioninfo));
    if (message_arena != submessage_arena) {
      positioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positioninfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.positioninfo_ = positioninfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_POSITION.positionInfo)
}

// -------------------------------------------------------------------

// S_POSITION

// int32 positionChanged = 1;
inline void S_POSITION::clear_positionchanged() {
  _impl_.positionchanged_ = 0;
}
inline int32_t S_POSITION::_internal_positionchanged() const {
  return _impl_.positionchanged_;
}
inline int32_t S_POSITION::positionchanged() const {
  // @@protoc_insertion_point(field_get:Protocol.S_POSITION.positionChanged)
  return _internal_positionchanged();
}
inline void S_POSITION::_internal_set_positionchanged(int32_t value) {
  
  _impl_.positionchanged_ = value;
}
inline void S_POSITION::set_positionchanged(int32_t value) {
  _internal_set_positionchanged(value);
  // @@protoc_insertion_point(field_set:Protocol.S_POSITION.positionChanged)
}

// .Protocol.PositionInfo positionInfo = 2;
inline bool S_POSITION::_internal_has_positioninfo() const {
  return this != internal_default_instance() && _impl_.positioninfo_ != nullptr;
}
inline bool S_POSITION::has_positioninfo() const {
  return _internal_has_positioninfo();
}
inline const ::Protocol::PositionInfo& S_POSITION::_internal_positioninfo() const {
  const ::Protocol::PositionInfo* p = _impl_.positioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PositionInfo&>(
      ::Protocol::_PositionInfo_default_instance_);
}
inline const ::Protocol::PositionInfo& S_POSITION::positioninfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_POSITION.positionInfo)
  return _internal_positioninfo();
}
inline void S_POSITION::unsafe_arena_set_allocated_positioninfo(
    ::Protocol::PositionInfo* positioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positioninfo_);
  }
  _impl_.positioninfo_ = positioninfo;
  if (positioninfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_POSITION.positionInfo)
}
inline ::Protocol::PositionInfo* S_POSITION::release_positioninfo() {
  
  ::Protocol::PositionInfo* temp = _impl_.positioninfo_;
  _impl_.positioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PositionInfo* S_POSITION::unsafe_arena_release_positioninfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_POSITION.positionInfo)
  
  ::Protocol::PositionInfo* temp = _impl_.positioninfo_;
  _impl_.positioninfo_ = nullptr;
  return temp;
}
inline ::Protocol::PositionInfo* S_POSITION::_internal_mutable_positioninfo() {
  
  if (_impl_.positioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PositionInfo>(GetArenaForAllocation());
    _impl_.positioninfo_ = p;
  }
  return _impl_.positioninfo_;
}
inline ::Protocol::PositionInfo* S_POSITION::mutable_positioninfo() {
  ::Protocol::PositionInfo* _msg = _internal_mutable_positioninfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_POSITION.positionInfo)
  return _msg;
}
inline void S_POSITION::set_allocated_positioninfo(::Protocol::PositionInfo* positioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positioninfo_);
  }
  if (positioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positioninfo));
    if (message_arena != submessage_arena) {
      positioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positioninfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.positioninfo_ = positioninfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_POSITION.positionInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
